//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace edzzn.DB
{
	/// <summary>
	/// Serializer DBModelSerializer for DomainClass DBModel.
	/// </summary>
	public partial class DBModelSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// DBModelSerializer Constructor
		/// </summary>
		public DBModelSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of DBModel.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"dBModel"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of DBModel.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleModelMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of DBModel in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one DBModel instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the DBModel element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			DBModel instanceOfDBModel = element as DBModel;
			global::System.Diagnostics.Debug.Assert(instanceOfDBModel != null, "Expecting an instance of DBModel!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfDBModel, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory DBModel instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, DBModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "elements":	// Relationship "ExampleModelHasElements"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <elements>
							ReadExampleModelHasElementsInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </elements>
						}
						break;
					case "tabla":	// Relationship "DBModelTieneTabla"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <tabla>
							ReadDBModelTieneTablaInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </tabla>
						}
						break;
					case "vista":	// Relationship "DBModelTieneVista"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <vista>
							ReadDBModelTieneVistaInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </vista>
						}
						break;
					case "procedimientoAlmacenado":	// Relationship "DBModelTieneProcedimientoAlmacenado"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <procedimientoAlmacenado>
							ReadDBModelTieneProcedimientoAlmacenadoInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </procedimientoAlmacenado>
						}
						break;
					case "relacion":	// Relationship "DBModelTieneRelacion"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <relacion>
							ReadDBModelTieneRelacionInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </relacion>
						}
						break;
					case "trigger":	// Relationship "DBModelTieneTrigger"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <trigger>
							ReadDBModelTieneTriggerInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </trigger>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ExampleModelHasElements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadExampleModelHasElementsInstances(DslModeling::SerializationContext serializationContext, DBModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newExampleElementOfExampleModelHasElementsSerializer = serializationContext.Directory.GetSerializer(ExampleElement.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newExampleElementOfExampleModelHasElementsSerializer != null, "Cannot find serializer for ExampleElement!");
				ExampleElement newExampleElementOfExampleModelHasElements = newExampleElementOfExampleModelHasElementsSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ExampleElement;
				if (newExampleElementOfExampleModelHasElements != null)
				{
					element.Elements.Add(newExampleElementOfExampleModelHasElements);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newExampleElementOfExampleModelHasElements.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newExampleElementOfExampleModelHasElements.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newExampleElementOfExampleModelHasElements, reader);
				}
				else
				{
					global::System.Type typeofExampleModelHasElements = typeof(ExampleModelHasElements);
					DslModeling::DomainRelationshipXmlSerializer newExampleModelHasElementsSerializer = serializationContext.Directory.GetSerializer(ExampleModelHasElements.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newExampleModelHasElementsSerializer != null, "Cannot find serializer for ExampleModelHasElements!");
					ExampleModelHasElements newExampleModelHasElements = newExampleModelHasElementsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ExampleModelHasElements;
					if (newExampleModelHasElements != null)
					{
						if (newExampleModelHasElements.GetType() == typeofExampleModelHasElements)
						{	// The relationship should be serialized in short-form.
							DBSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ExampleModelHasElements));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newExampleModelHasElements, ExampleModelHasElements.DBModelDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newExampleModelHasElements.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newExampleModelHasElements.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newExampleModelHasElements, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship DBModelTieneTabla.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadDBModelTieneTablaInstances(DslModeling::SerializationContext serializationContext, DBModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newDBModelTieneTablaSerializer = serializationContext.Directory.GetSerializer(DBModelTieneTabla.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newDBModelTieneTablaSerializer != null, "Cannot find serializer for DBModelTieneTabla!");
				DBModelTieneTabla newDBModelTieneTabla = newDBModelTieneTablaSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as DBModelTieneTabla;
				if (newDBModelTieneTabla != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newDBModelTieneTabla, DBModelTieneTabla.DBModelDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newDBModelTieneTabla.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newDBModelTieneTabla.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newDBModelTieneTabla, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newTablaOfDBModelTieneTablaSerializer = serializationContext.Directory.GetSerializer(Tabla.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newTablaOfDBModelTieneTablaSerializer != null, "Cannot find serializer for Tabla!");
					Tabla newTablaOfDBModelTieneTabla = newTablaOfDBModelTieneTablaSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Tabla;
					if (newTablaOfDBModelTieneTabla != null)
					{
						DBSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(DBModelTieneTabla));
						element.Tabla.Add(newTablaOfDBModelTieneTabla);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newTablaOfDBModelTieneTabla.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newTablaOfDBModelTieneTabla.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newTablaOfDBModelTieneTabla, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship DBModelTieneVista.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadDBModelTieneVistaInstances(DslModeling::SerializationContext serializationContext, DBModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newDBModelTieneVistaSerializer = serializationContext.Directory.GetSerializer(DBModelTieneVista.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newDBModelTieneVistaSerializer != null, "Cannot find serializer for DBModelTieneVista!");
				DBModelTieneVista newDBModelTieneVista = newDBModelTieneVistaSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as DBModelTieneVista;
				if (newDBModelTieneVista != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newDBModelTieneVista, DBModelTieneVista.DBModelDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newDBModelTieneVista.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newDBModelTieneVista.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newDBModelTieneVista, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newVistaOfDBModelTieneVistaSerializer = serializationContext.Directory.GetSerializer(Vista.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newVistaOfDBModelTieneVistaSerializer != null, "Cannot find serializer for Vista!");
					Vista newVistaOfDBModelTieneVista = newVistaOfDBModelTieneVistaSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Vista;
					if (newVistaOfDBModelTieneVista != null)
					{
						DBSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(DBModelTieneVista));
						element.Vista.Add(newVistaOfDBModelTieneVista);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newVistaOfDBModelTieneVista.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newVistaOfDBModelTieneVista.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newVistaOfDBModelTieneVista, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship DBModelTieneProcedimientoAlmacenado.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadDBModelTieneProcedimientoAlmacenadoInstances(DslModeling::SerializationContext serializationContext, DBModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newDBModelTieneProcedimientoAlmacenadoSerializer = serializationContext.Directory.GetSerializer(DBModelTieneProcedimientoAlmacenado.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newDBModelTieneProcedimientoAlmacenadoSerializer != null, "Cannot find serializer for DBModelTieneProcedimientoAlmacenado!");
				DBModelTieneProcedimientoAlmacenado newDBModelTieneProcedimientoAlmacenado = newDBModelTieneProcedimientoAlmacenadoSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as DBModelTieneProcedimientoAlmacenado;
				if (newDBModelTieneProcedimientoAlmacenado != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newDBModelTieneProcedimientoAlmacenado, DBModelTieneProcedimientoAlmacenado.DBModelDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newDBModelTieneProcedimientoAlmacenado.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newDBModelTieneProcedimientoAlmacenado.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newDBModelTieneProcedimientoAlmacenado, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newProcedimientoAlmacenadoOfDBModelTieneProcedimientoAlmacenadoSerializer = serializationContext.Directory.GetSerializer(ProcedimientoAlmacenado.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newProcedimientoAlmacenadoOfDBModelTieneProcedimientoAlmacenadoSerializer != null, "Cannot find serializer for ProcedimientoAlmacenado!");
					ProcedimientoAlmacenado newProcedimientoAlmacenadoOfDBModelTieneProcedimientoAlmacenado = newProcedimientoAlmacenadoOfDBModelTieneProcedimientoAlmacenadoSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ProcedimientoAlmacenado;
					if (newProcedimientoAlmacenadoOfDBModelTieneProcedimientoAlmacenado != null)
					{
						DBSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(DBModelTieneProcedimientoAlmacenado));
						element.ProcedimientoAlmacenado.Add(newProcedimientoAlmacenadoOfDBModelTieneProcedimientoAlmacenado);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newProcedimientoAlmacenadoOfDBModelTieneProcedimientoAlmacenado.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newProcedimientoAlmacenadoOfDBModelTieneProcedimientoAlmacenado.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newProcedimientoAlmacenadoOfDBModelTieneProcedimientoAlmacenado, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship DBModelTieneRelacion.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadDBModelTieneRelacionInstances(DslModeling::SerializationContext serializationContext, DBModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newDBModelTieneRelacionSerializer = serializationContext.Directory.GetSerializer(DBModelTieneRelacion.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newDBModelTieneRelacionSerializer != null, "Cannot find serializer for DBModelTieneRelacion!");
				DBModelTieneRelacion newDBModelTieneRelacion = newDBModelTieneRelacionSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as DBModelTieneRelacion;
				if (newDBModelTieneRelacion != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newDBModelTieneRelacion, DBModelTieneRelacion.DBModelDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newDBModelTieneRelacion.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newDBModelTieneRelacion.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newDBModelTieneRelacion, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newRelacionOfDBModelTieneRelacionSerializer = serializationContext.Directory.GetSerializer(Relacion.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newRelacionOfDBModelTieneRelacionSerializer != null, "Cannot find serializer for Relacion!");
					Relacion newRelacionOfDBModelTieneRelacion = newRelacionOfDBModelTieneRelacionSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Relacion;
					if (newRelacionOfDBModelTieneRelacion != null)
					{
						DBSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(DBModelTieneRelacion));
						element.Relacion.Add(newRelacionOfDBModelTieneRelacion);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newRelacionOfDBModelTieneRelacion.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newRelacionOfDBModelTieneRelacion.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newRelacionOfDBModelTieneRelacion, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship DBModelTieneTrigger.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModel instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadDBModelTieneTriggerInstances(DslModeling::SerializationContext serializationContext, DBModel element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newDBModelTieneTriggerSerializer = serializationContext.Directory.GetSerializer(DBModelTieneTrigger.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newDBModelTieneTriggerSerializer != null, "Cannot find serializer for DBModelTieneTrigger!");
				DBModelTieneTrigger newDBModelTieneTrigger = newDBModelTieneTriggerSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as DBModelTieneTrigger;
				if (newDBModelTieneTrigger != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newDBModelTieneTrigger, DBModelTieneTrigger.DBModelDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newDBModelTieneTrigger.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newDBModelTieneTrigger.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newDBModelTieneTrigger, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newTriggerOfDBModelTieneTriggerSerializer = serializationContext.Directory.GetSerializer(Trigger.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newTriggerOfDBModelTieneTriggerSerializer != null, "Cannot find serializer for Trigger!");
					Trigger newTriggerOfDBModelTieneTrigger = newTriggerOfDBModelTieneTriggerSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Trigger;
					if (newTriggerOfDBModelTieneTrigger != null)
					{
						DBSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(DBModelTieneTrigger));
						element.Trigger.Add(newTriggerOfDBModelTieneTrigger);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newTriggerOfDBModelTieneTrigger.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newTriggerOfDBModelTieneTrigger.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newTriggerOfDBModelTieneTrigger, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of DBModel based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized DBModel, a new DBModel instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created DBModel instance, or null if the reader is not pointing to a serialized DBModel instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModel" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "DBModel".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						DBModelSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of DBModel based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of DBModel.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new DBModel instance should be created.</param>	
		/// <returns>Created DBModel instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new DBModel(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from DBModel, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from DBModel.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModel.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including DBModel itself) instance of DBModel based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModel" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "DBModel".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						DBModelSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of DBModel based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, DBModel.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModel, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModel.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModel.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized DBModel instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModel instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the DBModel instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the DBModel instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one DBModel instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModel instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModel instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModel instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			DBModel instance = element as DBModel;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModel!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModel instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, DBModel element, global::System.Xml.XmlWriter writer)
		{
			// ExampleModelHasElements
			global::System.Collections.ObjectModel.ReadOnlyCollection<ExampleModelHasElements> allExampleModelHasElementsInstances = ExampleModelHasElements.GetLinksToElements(element);
			if (!serializationContext.Result.Failed && allExampleModelHasElementsInstances.Count > 0)
			{
				writer.WriteStartElement("elements");
				global::System.Type typeofExampleModelHasElements = typeof(ExampleModelHasElements);
				foreach (ExampleModelHasElements eachExampleModelHasElementsInstance in allExampleModelHasElementsInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachExampleModelHasElementsInstance.GetType() != typeofExampleModelHasElements)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachExampleModelHasElementsInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachExampleModelHasElementsInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachExampleModelHasElementsInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachExampleModelHasElementsInstance.Element;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// DBModelTieneTabla
			global::System.Collections.ObjectModel.ReadOnlyCollection<DBModelTieneTabla> allDBModelTieneTablaInstances = DBModelTieneTabla.GetLinksToTabla(element);
			if (!serializationContext.Result.Failed && allDBModelTieneTablaInstances.Count > 0)
			{
				writer.WriteStartElement("tabla");
				foreach (DBModelTieneTabla eachDBModelTieneTablaInstance in allDBModelTieneTablaInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachDBModelTieneTablaInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachDBModelTieneTablaInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachDBModelTieneTablaInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// DBModelTieneVista
			global::System.Collections.ObjectModel.ReadOnlyCollection<DBModelTieneVista> allDBModelTieneVistaInstances = DBModelTieneVista.GetLinksToVista(element);
			if (!serializationContext.Result.Failed && allDBModelTieneVistaInstances.Count > 0)
			{
				writer.WriteStartElement("vista");
				foreach (DBModelTieneVista eachDBModelTieneVistaInstance in allDBModelTieneVistaInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachDBModelTieneVistaInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachDBModelTieneVistaInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachDBModelTieneVistaInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// DBModelTieneProcedimientoAlmacenado
			global::System.Collections.ObjectModel.ReadOnlyCollection<DBModelTieneProcedimientoAlmacenado> allDBModelTieneProcedimientoAlmacenadoInstances = DBModelTieneProcedimientoAlmacenado.GetLinksToProcedimientoAlmacenado(element);
			if (!serializationContext.Result.Failed && allDBModelTieneProcedimientoAlmacenadoInstances.Count > 0)
			{
				writer.WriteStartElement("procedimientoAlmacenado");
				foreach (DBModelTieneProcedimientoAlmacenado eachDBModelTieneProcedimientoAlmacenadoInstance in allDBModelTieneProcedimientoAlmacenadoInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachDBModelTieneProcedimientoAlmacenadoInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachDBModelTieneProcedimientoAlmacenadoInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachDBModelTieneProcedimientoAlmacenadoInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// DBModelTieneRelacion
			global::System.Collections.ObjectModel.ReadOnlyCollection<DBModelTieneRelacion> allDBModelTieneRelacionInstances = DBModelTieneRelacion.GetLinksToRelacion(element);
			if (!serializationContext.Result.Failed && allDBModelTieneRelacionInstances.Count > 0)
			{
				writer.WriteStartElement("relacion");
				foreach (DBModelTieneRelacion eachDBModelTieneRelacionInstance in allDBModelTieneRelacionInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachDBModelTieneRelacionInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachDBModelTieneRelacionInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachDBModelTieneRelacionInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// DBModelTieneTrigger
			global::System.Collections.ObjectModel.ReadOnlyCollection<DBModelTieneTrigger> allDBModelTieneTriggerInstances = DBModelTieneTrigger.GetLinksToTrigger(element);
			if (!serializationContext.Result.Failed && allDBModelTieneTriggerInstances.Count > 0)
			{
				writer.WriteStartElement("trigger");
				foreach (DBModelTieneTrigger eachDBModelTieneTriggerInstance in allDBModelTieneTriggerInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachDBModelTieneTriggerInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachDBModelTieneTriggerInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachDBModelTieneTriggerInstance, writer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given DBModel instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModel instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the DBModel instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			DBModel instance = element as DBModel;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModel!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModel instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer ExampleElementSerializer for DomainClass ExampleElement.
	/// </summary>
	public partial class ExampleElementSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ExampleElementSerializer Constructor
		/// </summary>
		public ExampleElementSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ExampleElement.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleElement"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ExampleElement.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleElementMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ExampleElement in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ExampleElement instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ExampleElement element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ExampleElement instanceOfExampleElement = element as ExampleElement;
			global::System.Diagnostics.Debug.Assert(instanceOfExampleElement != null, "Expecting an instance of ExampleElement");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribName, out valueOfName))
					{
						instanceOfExampleElement.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			ExampleElement instanceOfExampleElement = element as ExampleElement;
			global::System.Diagnostics.Debug.Assert(instanceOfExampleElement != null, "Expecting an instance of ExampleElement!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfExampleElement, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory ExampleElement instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, ExampleElement element, global::System.Xml.XmlReader reader)
		{
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				if (string.Compare(reader.LocalName, "targets", global::System.StringComparison.CurrentCulture) == 0)
				{
					if (reader.IsEmptyElement)
					{	// No instance of this relationship, just skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
					else
					{
						DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <targets>
						ReadExampleElementReferencesTargetsInstances(serializationContext, element, reader);
						DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </targets>
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ExampleElementReferencesTargets.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadExampleElementReferencesTargetsInstances(DslModeling::SerializationContext serializationContext, ExampleElement element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newExampleElementMonikerOfExampleElementReferencesTargetsSerializer = serializationContext.Directory.GetSerializer(ExampleElement.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newExampleElementMonikerOfExampleElementReferencesTargetsSerializer != null, "Cannot find serializer for ExampleElement!");
				DslModeling::Moniker newExampleElementMonikerOfExampleElementReferencesTargets = newExampleElementMonikerOfExampleElementReferencesTargetsSerializer.TryCreateMonikerInstance(serializationContext, reader, element, ExampleElementReferencesTargets.DomainClassId, element.Partition);
				if (newExampleElementMonikerOfExampleElementReferencesTargets != null)
				{
					new ExampleElementReferencesTargets(element.Partition, new DslModeling::RoleAssignment(ExampleElementReferencesTargets.SourceDomainRoleId, element), new DslModeling::RoleAssignment(ExampleElementReferencesTargets.TargetDomainRoleId, newExampleElementMonikerOfExampleElementReferencesTargets));
					DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
				}
				else
				{
					global::System.Type typeofExampleElementReferencesTargets = typeof(ExampleElementReferencesTargets);
					DslModeling::DomainRelationshipXmlSerializer newExampleElementReferencesTargetsSerializer = serializationContext.Directory.GetSerializer(ExampleElementReferencesTargets.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newExampleElementReferencesTargetsSerializer != null, "Cannot find serializer for ExampleElementReferencesTargets!");
					ExampleElementReferencesTargets newExampleElementReferencesTargets = newExampleElementReferencesTargetsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ExampleElementReferencesTargets;
					if (newExampleElementReferencesTargets != null)
					{
						if (newExampleElementReferencesTargets.GetType() == typeofExampleElementReferencesTargets)
						{	// The relationship should be serialized in short-form.
							DBSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ExampleElementReferencesTargets));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newExampleElementReferencesTargets, ExampleElementReferencesTargets.SourceDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newExampleElementReferencesTargets.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newExampleElementReferencesTargets.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newExampleElementReferencesTargets, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ExampleElement based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ExampleElement, a new ExampleElement instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ExampleElement instance, or null if the reader is not pointing to a serialized ExampleElement instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ExampleElement" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ExampleElement".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ExampleElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ExampleElementSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ExampleElement based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ExampleElement.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ExampleElement instance should be created.</param>	
		/// <returns>Created ExampleElement instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ExampleElement(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ExampleElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ExampleElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ExampleElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ExampleElement itself) instance of ExampleElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ExampleElement" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ExampleElement".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ExampleElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ExampleElementSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ExampleElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ExampleElement.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ExampleElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ExampleElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ExampleElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ExampleElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleElement instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ExampleElement instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ExampleElement instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ExampleElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ExampleElement instanceOfExampleElement = element as ExampleElement;
			global::System.Diagnostics.Debug.Assert(instanceOfExampleElement != null, "Expecting an instance of ExampleElement");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfExampleElement.Name;
				if (!serializationContext.Result.Failed)
				{
					DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "name", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			ExampleElement instance = element as ExampleElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ExampleElement!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, ExampleElement element, global::System.Xml.XmlWriter writer)
		{
			// ExampleElementReferencesTargets
			global::System.Collections.ObjectModel.ReadOnlyCollection<ExampleElementReferencesTargets> allExampleElementReferencesTargetsInstances = ExampleElementReferencesTargets.GetLinksToTargets(element);
			if (!serializationContext.Result.Failed && allExampleElementReferencesTargetsInstances.Count > 0)
			{
				DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(ExampleElementReferencesTargets.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
				global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for ExampleElementReferencesTargets!");
	
				writer.WriteStartElement("targets");
				global::System.Type typeofExampleElementReferencesTargets = typeof(ExampleElementReferencesTargets);
				foreach (ExampleElementReferencesTargets eachExampleElementReferencesTargetsInstance in allExampleElementReferencesTargetsInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachExampleElementReferencesTargetsInstance.GetType() != typeofExampleElementReferencesTargets)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachExampleElementReferencesTargetsInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachExampleElementReferencesTargetsInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachExampleElementReferencesTargetsInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachExampleElementReferencesTargetsInstance.Target;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.WriteMoniker(serializationContext, targetElement, writer, element, relSerializer);
					}
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ExampleElement instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ExampleElement instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ExampleElement instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ExampleElement instance = element as ExampleElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ExampleElement!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ExampleElement instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ExampleElement instance = element as ExampleElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ExampleElement!");
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer TablaSerializer for DomainClass Tabla.
	/// </summary>
	public partial class TablaSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// TablaSerializer Constructor
		/// </summary>
		public TablaSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Tabla.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"tabla"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Tabla.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Tabla"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Tabla in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nombre"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Tabla instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Tabla element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Tabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Tabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			Tabla instanceOfTabla = element as Tabla;
			global::System.Diagnostics.Debug.Assert(instanceOfTabla != null, "Expecting an instance of Tabla");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				string attribNombre = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nombre");
				if (attribNombre != null)
				{
					global::System.String valueOfNombre;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNombre, out valueOfNombre))
					{
						instanceOfTabla.Nombre = valueOfNombre;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nombre", typeof(global::System.String), attribNombre);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Tabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			Tabla instanceOfTabla = element as Tabla;
			global::System.Diagnostics.Debug.Assert(instanceOfTabla != null, "Expecting an instance of Tabla!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfTabla, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory Tabla instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, Tabla element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "campo":	// Relationship "TablaTieneCampo"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <campo>
							ReadTablaTieneCampoInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </campo>
						}
						break;
					case "clavePrimaria":	// Relationship "TablaTieneClavePrimaria"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <clavePrimaria>
							ReadTablaTieneClavePrimariaInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </clavePrimaria>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship TablaTieneCampo.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Tabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadTablaTieneCampoInstances(DslModeling::SerializationContext serializationContext, Tabla element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newTablaTieneCampoSerializer = serializationContext.Directory.GetSerializer(TablaTieneCampo.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newTablaTieneCampoSerializer != null, "Cannot find serializer for TablaTieneCampo!");
				TablaTieneCampo newTablaTieneCampo = newTablaTieneCampoSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as TablaTieneCampo;
				if (newTablaTieneCampo != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newTablaTieneCampo, TablaTieneCampo.TablaDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newTablaTieneCampo.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newTablaTieneCampo.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newTablaTieneCampo, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newCampoOfTablaTieneCampoSerializer = serializationContext.Directory.GetSerializer(Campo.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newCampoOfTablaTieneCampoSerializer != null, "Cannot find serializer for Campo!");
					Campo newCampoOfTablaTieneCampo = newCampoOfTablaTieneCampoSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Campo;
					if (newCampoOfTablaTieneCampo != null)
					{
						DBSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(TablaTieneCampo));
						element.Campo.Add(newCampoOfTablaTieneCampo);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newCampoOfTablaTieneCampo.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newCampoOfTablaTieneCampo.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newCampoOfTablaTieneCampo, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship TablaTieneClavePrimaria.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Tabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadTablaTieneClavePrimariaInstances(DslModeling::SerializationContext serializationContext, Tabla element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newTablaTieneClavePrimariaSerializer = serializationContext.Directory.GetSerializer(TablaTieneClavePrimaria.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newTablaTieneClavePrimariaSerializer != null, "Cannot find serializer for TablaTieneClavePrimaria!");
				TablaTieneClavePrimaria newTablaTieneClavePrimaria = newTablaTieneClavePrimariaSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as TablaTieneClavePrimaria;
				if (newTablaTieneClavePrimaria != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newTablaTieneClavePrimaria, TablaTieneClavePrimaria.TablaDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newTablaTieneClavePrimaria.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newTablaTieneClavePrimaria.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newTablaTieneClavePrimaria, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newClavePrimariaOfTablaTieneClavePrimariaSerializer = serializationContext.Directory.GetSerializer(ClavePrimaria.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newClavePrimariaOfTablaTieneClavePrimariaSerializer != null, "Cannot find serializer for ClavePrimaria!");
					ClavePrimaria newClavePrimariaOfTablaTieneClavePrimaria = newClavePrimariaOfTablaTieneClavePrimariaSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ClavePrimaria;
					if (newClavePrimariaOfTablaTieneClavePrimaria != null)
					{
						DBSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(TablaTieneClavePrimaria));
						element.ClavePrimaria.Add(newClavePrimariaOfTablaTieneClavePrimaria);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newClavePrimariaOfTablaTieneClavePrimaria.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newClavePrimariaOfTablaTieneClavePrimaria.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newClavePrimariaOfTablaTieneClavePrimaria, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Tabla based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Tabla, a new Tabla instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Tabla instance, or null if the reader is not pointing to a serialized Tabla instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Tabla" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Tabla".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						TablaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TablaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Tabla based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Tabla.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Tabla instance should be created.</param>	
		/// <returns>Created Tabla instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Tabla(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Tabla, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Tabla.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Tabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Tabla itself) instance of Tabla based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Tabla" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Tabla".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TablaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TablaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Tabla based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Tabla.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Tabla, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Tabla.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Tabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Tabla instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Tabla instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Tabla instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Tabla instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Tabla instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Tabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Tabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			Tabla instanceOfTabla = element as Tabla;
			global::System.Diagnostics.Debug.Assert(instanceOfTabla != null, "Expecting an instance of Tabla");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfTabla.Nombre;
				if (!serializationContext.Result.Failed)
				{
					DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nombre", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Tabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			Tabla instance = element as Tabla;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Tabla!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Tabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, Tabla element, global::System.Xml.XmlWriter writer)
		{
			// TablaTieneCampo
			global::System.Collections.ObjectModel.ReadOnlyCollection<TablaTieneCampo> allTablaTieneCampoInstances = TablaTieneCampo.GetLinksToCampo(element);
			if (!serializationContext.Result.Failed && allTablaTieneCampoInstances.Count > 0)
			{
				writer.WriteStartElement("campo");
				foreach (TablaTieneCampo eachTablaTieneCampoInstance in allTablaTieneCampoInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachTablaTieneCampoInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachTablaTieneCampoInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachTablaTieneCampoInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// TablaTieneClavePrimaria
			global::System.Collections.ObjectModel.ReadOnlyCollection<TablaTieneClavePrimaria> allTablaTieneClavePrimariaInstances = TablaTieneClavePrimaria.GetLinksToClavePrimaria(element);
			if (!serializationContext.Result.Failed && allTablaTieneClavePrimariaInstances.Count > 0)
			{
				writer.WriteStartElement("clavePrimaria");
				foreach (TablaTieneClavePrimaria eachTablaTieneClavePrimariaInstance in allTablaTieneClavePrimariaInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachTablaTieneClavePrimariaInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachTablaTieneClavePrimariaInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachTablaTieneClavePrimariaInstance, writer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Tabla instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Tabla instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Tabla instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Tabla instance = element as Tabla;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Tabla!");
	
			string key = instance.Nombre;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Tabla instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Tabla instance = element as Tabla;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Tabla!");
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer VistaSerializer for DomainClass Vista.
	/// </summary>
	public partial class VistaSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// VistaSerializer Constructor
		/// </summary>
		public VistaSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Vista.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"vista"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Vista.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Vista"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Vista in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Vista instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Vista element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Vista instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Vista instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			Vista instanceOfVista = element as Vista;
			global::System.Diagnostics.Debug.Assert(instanceOfVista != null, "Expecting an instance of Vista");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribName, out valueOfName))
					{
						instanceOfVista.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
			// SqlQuery
			if (!serializationContext.Result.Failed)
			{
				string attribSqlQuery = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sqlQuery");
				if (attribSqlQuery != null)
				{
					global::System.String valueOfSqlQuery;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSqlQuery, out valueOfSqlQuery))
					{
						instanceOfVista.SqlQuery = valueOfSqlQuery;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sqlQuery", typeof(global::System.String), attribSqlQuery);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Vista instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Vista based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Vista, a new Vista instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Vista instance, or null if the reader is not pointing to a serialized Vista instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Vista" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Vista".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						VistaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as VistaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Vista based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Vista.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Vista instance should be created.</param>	
		/// <returns>Created Vista instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Vista(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Vista, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Vista.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Vista.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Vista itself) instance of Vista based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Vista" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Vista".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						VistaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as VistaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Vista based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Vista.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Vista, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Vista.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Vista.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Vista instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Vista instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Vista instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Vista instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Vista instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Vista instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Vista instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			Vista instanceOfVista = element as Vista;
			global::System.Diagnostics.Debug.Assert(instanceOfVista != null, "Expecting an instance of Vista");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfVista.Name;
				if (!serializationContext.Result.Failed)
				{
					DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "name", propValue);
				}
			}
			// SqlQuery
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfVista.SqlQuery;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sqlQuery", propValue);
	
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Vista instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Vista instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Vista instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Vista instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Vista instance = element as Vista;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Vista!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Vista instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Vista instance = element as Vista;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Vista!");
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer ProcedimientoAlmacenadoSerializer for DomainClass ProcedimientoAlmacenado.
	/// </summary>
	public partial class ProcedimientoAlmacenadoSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ProcedimientoAlmacenadoSerializer Constructor
		/// </summary>
		public ProcedimientoAlmacenadoSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ProcedimientoAlmacenado.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"procedimientoAlmacenado"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ProcedimientoAlmacenado.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"ProcedimientoAlmacenado"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ProcedimientoAlmacenado in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nombre"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ProcedimientoAlmacenado instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ProcedimientoAlmacenado element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ProcedimientoAlmacenado instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ProcedimientoAlmacenado instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ProcedimientoAlmacenado instanceOfProcedimientoAlmacenado = element as ProcedimientoAlmacenado;
			global::System.Diagnostics.Debug.Assert(instanceOfProcedimientoAlmacenado != null, "Expecting an instance of ProcedimientoAlmacenado");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				string attribNombre = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nombre");
				if (attribNombre != null)
				{
					global::System.String valueOfNombre;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNombre, out valueOfNombre))
					{
						instanceOfProcedimientoAlmacenado.Nombre = valueOfNombre;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nombre", typeof(global::System.String), attribNombre);
					}
				}
			}
			// SqlQuery
			if (!serializationContext.Result.Failed)
			{
				string attribSqlQuery = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sqlQuery");
				if (attribSqlQuery != null)
				{
					global::System.String valueOfSqlQuery;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSqlQuery, out valueOfSqlQuery))
					{
						instanceOfProcedimientoAlmacenado.SqlQuery = valueOfSqlQuery;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sqlQuery", typeof(global::System.String), attribSqlQuery);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ProcedimientoAlmacenado instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ProcedimientoAlmacenado based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ProcedimientoAlmacenado, a new ProcedimientoAlmacenado instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ProcedimientoAlmacenado instance, or null if the reader is not pointing to a serialized ProcedimientoAlmacenado instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ProcedimientoAlmacenado" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ProcedimientoAlmacenado".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ProcedimientoAlmacenadoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ProcedimientoAlmacenadoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ProcedimientoAlmacenado based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ProcedimientoAlmacenado.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ProcedimientoAlmacenado instance should be created.</param>	
		/// <returns>Created ProcedimientoAlmacenado instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ProcedimientoAlmacenado(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ProcedimientoAlmacenado, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ProcedimientoAlmacenado.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ProcedimientoAlmacenado.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ProcedimientoAlmacenado itself) instance of ProcedimientoAlmacenado based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ProcedimientoAlmacenado" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ProcedimientoAlmacenado".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ProcedimientoAlmacenadoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ProcedimientoAlmacenadoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ProcedimientoAlmacenado based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ProcedimientoAlmacenado.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ProcedimientoAlmacenado, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ProcedimientoAlmacenado.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ProcedimientoAlmacenado.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ProcedimientoAlmacenado instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ProcedimientoAlmacenado instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ProcedimientoAlmacenado instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ProcedimientoAlmacenado instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ProcedimientoAlmacenado instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ProcedimientoAlmacenado instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ProcedimientoAlmacenado instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ProcedimientoAlmacenado instanceOfProcedimientoAlmacenado = element as ProcedimientoAlmacenado;
			global::System.Diagnostics.Debug.Assert(instanceOfProcedimientoAlmacenado != null, "Expecting an instance of ProcedimientoAlmacenado");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProcedimientoAlmacenado.Nombre;
				if (!serializationContext.Result.Failed)
				{
					DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nombre", propValue);
				}
			}
			// SqlQuery
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfProcedimientoAlmacenado.SqlQuery;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sqlQuery", propValue);
	
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ProcedimientoAlmacenado instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ProcedimientoAlmacenado instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ProcedimientoAlmacenado instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ProcedimientoAlmacenado instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ProcedimientoAlmacenado instance = element as ProcedimientoAlmacenado;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ProcedimientoAlmacenado!");
	
			string key = instance.Nombre;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ProcedimientoAlmacenado instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ProcedimientoAlmacenado instance = element as ProcedimientoAlmacenado;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ProcedimientoAlmacenado!");
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer CampoSerializer for DomainClass Campo.
	/// </summary>
	public partial class CampoSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// CampoSerializer Constructor
		/// </summary>
		public CampoSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Campo.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"campo"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Campo.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerCampo"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Campo in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nombre"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Campo instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Campo element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Campo instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Campo instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			Campo instanceOfCampo = element as Campo;
			global::System.Diagnostics.Debug.Assert(instanceOfCampo != null, "Expecting an instance of Campo");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				string attribNombre = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nombre");
				if (attribNombre != null)
				{
					global::System.String valueOfNombre;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNombre, out valueOfNombre))
					{
						instanceOfCampo.Nombre = valueOfNombre;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nombre", typeof(global::System.String), attribNombre);
					}
				}
			}
			// Valor
			if (!serializationContext.Result.Failed)
			{
				string attribValor = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "valor");
				if (attribValor != null)
				{
					global::System.String valueOfValor;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribValor, out valueOfValor))
					{
						instanceOfCampo.Valor = valueOfValor;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "valor", typeof(global::System.String), attribValor);
					}
				}
			}
			// Tipo
			if (!serializationContext.Result.Failed)
			{
				string attribTipo = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "tipo");
				if (attribTipo != null)
				{
					global::System.String valueOfTipo;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTipo, out valueOfTipo))
					{
						instanceOfCampo.Tipo = valueOfTipo;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "tipo", typeof(global::System.String), attribTipo);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Campo instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Campo based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Campo, a new Campo instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Campo instance, or null if the reader is not pointing to a serialized Campo instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Campo" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Campo".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						CampoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CampoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Campo based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Campo.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Campo instance should be created.</param>	
		/// <returns>Created Campo instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Campo(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Campo, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Campo.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Campo.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Campo itself) instance of Campo based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Campo" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Campo".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						CampoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CampoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Campo based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Campo.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Campo, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Campo.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Campo.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Campo instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Campo instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Campo instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Campo instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Campo instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Campo instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Campo instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			Campo instanceOfCampo = element as Campo;
			global::System.Diagnostics.Debug.Assert(instanceOfCampo != null, "Expecting an instance of Campo");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfCampo.Nombre;
				if (!serializationContext.Result.Failed)
				{
					DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nombre", propValue);
				}
			}
			// Valor
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfCampo.Valor;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "valor", propValue);
	
				}
			}
			// Tipo
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfCampo.Tipo;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "tipo", propValue);
	
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Campo instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Campo instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Campo instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Campo instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Campo instance = element as Campo;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Campo!");
	
			string key = instance.Nombre;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.Tabla;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Campo instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Campo instance = element as Campo;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Campo!");
			DslModeling::ModelElement container = instance.Tabla;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer ClavePrimariaSerializer for DomainClass ClavePrimaria.
	/// </summary>
	public partial class ClavePrimariaSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ClavePrimariaSerializer Constructor
		/// </summary>
		public ClavePrimariaSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ClavePrimaria.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"clavePrimaria"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ClavePrimaria.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerClavePrimaria"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ClavePrimaria in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nombre"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ClavePrimaria instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ClavePrimaria element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClavePrimaria instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClavePrimaria instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ClavePrimaria instanceOfClavePrimaria = element as ClavePrimaria;
			global::System.Diagnostics.Debug.Assert(instanceOfClavePrimaria != null, "Expecting an instance of ClavePrimaria");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				string attribNombre = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nombre");
				if (attribNombre != null)
				{
					global::System.String valueOfNombre;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNombre, out valueOfNombre))
					{
						instanceOfClavePrimaria.Nombre = valueOfNombre;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nombre", typeof(global::System.String), attribNombre);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClavePrimaria instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ClavePrimaria based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ClavePrimaria, a new ClavePrimaria instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ClavePrimaria instance, or null if the reader is not pointing to a serialized ClavePrimaria instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClavePrimaria" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ClavePrimaria".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ClavePrimariaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClavePrimariaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ClavePrimaria based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ClavePrimaria.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ClavePrimaria instance should be created.</param>	
		/// <returns>Created ClavePrimaria instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ClavePrimaria(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClavePrimaria, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ClavePrimaria.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClavePrimaria.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ClavePrimaria itself) instance of ClavePrimaria based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClavePrimaria" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ClavePrimaria".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ClavePrimariaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClavePrimariaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ClavePrimaria based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ClavePrimaria.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClavePrimaria, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClavePrimaria.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClavePrimaria.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ClavePrimaria instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClavePrimaria instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ClavePrimaria instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClavePrimaria instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ClavePrimaria instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClavePrimaria instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClavePrimaria instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ClavePrimaria instanceOfClavePrimaria = element as ClavePrimaria;
			global::System.Diagnostics.Debug.Assert(instanceOfClavePrimaria != null, "Expecting an instance of ClavePrimaria");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfClavePrimaria.Nombre;
				if (!serializationContext.Result.Failed)
				{
					DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nombre", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClavePrimaria instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClavePrimaria instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClavePrimaria instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClavePrimaria instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClavePrimaria instance = element as ClavePrimaria;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClavePrimaria!");
	
			string key = instance.Nombre;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.Tabla;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClavePrimaria instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClavePrimaria instance = element as ClavePrimaria;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClavePrimaria!");
			DslModeling::ModelElement container = instance.Tabla;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer RelacionSerializer for DomainClass Relacion.
	/// </summary>
	public partial class RelacionSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// RelacionSerializer Constructor
		/// </summary>
		public RelacionSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Relacion.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"relacion"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Relacion.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerRelacion"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Relacion in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nombre"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Relacion instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Relacion element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Relacion instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Relacion instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			Relacion instanceOfRelacion = element as Relacion;
			global::System.Diagnostics.Debug.Assert(instanceOfRelacion != null, "Expecting an instance of Relacion");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				string attribNombre = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nombre");
				if (attribNombre != null)
				{
					global::System.String valueOfNombre;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNombre, out valueOfNombre))
					{
						instanceOfRelacion.Nombre = valueOfNombre;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nombre", typeof(global::System.String), attribNombre);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Relacion instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			Relacion instanceOfRelacion = element as Relacion;
			global::System.Diagnostics.Debug.Assert(instanceOfRelacion != null, "Expecting an instance of Relacion!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfRelacion, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory Relacion instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, Relacion element, global::System.Xml.XmlReader reader)
		{
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				if (string.Compare(reader.LocalName, "tabla", global::System.StringComparison.CurrentCulture) == 0)
				{
					if (reader.IsEmptyElement)
					{	// No instance of this relationship, just skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
					else
					{
						DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <tabla>
						ReadRelacionReferenciasTablaInstances(serializationContext, element, reader);
						DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </tabla>
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship RelacionReferenciasTabla.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Relacion instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadRelacionReferenciasTablaInstances(DslModeling::SerializationContext serializationContext, Relacion element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newRelacionReferenciasTablaSerializer = serializationContext.Directory.GetSerializer(RelacionReferenciasTabla.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newRelacionReferenciasTablaSerializer != null, "Cannot find serializer for RelacionReferenciasTabla!");
				RelacionReferenciasTabla newRelacionReferenciasTabla = newRelacionReferenciasTablaSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as RelacionReferenciasTabla;
				if (newRelacionReferenciasTabla != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newRelacionReferenciasTabla, RelacionReferenciasTabla.RelacionDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newRelacionReferenciasTabla.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newRelacionReferenciasTabla.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newRelacionReferenciasTabla, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newTablaMonikerOfRelacionReferenciasTablaSerializer = serializationContext.Directory.GetSerializer(Tabla.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newTablaMonikerOfRelacionReferenciasTablaSerializer != null, "Cannot find serializer for Tabla!");
					DslModeling::Moniker newTablaMonikerOfRelacionReferenciasTabla = newTablaMonikerOfRelacionReferenciasTablaSerializer.TryCreateMonikerInstance(serializationContext, reader, element, RelacionReferenciasTabla.DomainClassId, element.Partition);
					if (newTablaMonikerOfRelacionReferenciasTabla != null)
					{
						DBSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(RelacionReferenciasTabla));
						new RelacionReferenciasTabla(element.Partition, new DslModeling::RoleAssignment(RelacionReferenciasTabla.RelacionDomainRoleId, element), new DslModeling::RoleAssignment(RelacionReferenciasTabla.TablaDomainRoleId, newTablaMonikerOfRelacionReferenciasTabla));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Relacion based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Relacion, a new Relacion instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Relacion instance, or null if the reader is not pointing to a serialized Relacion instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Relacion" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Relacion".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						RelacionSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as RelacionSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Relacion based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Relacion.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Relacion instance should be created.</param>	
		/// <returns>Created Relacion instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Relacion(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Relacion, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Relacion.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Relacion.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Relacion itself) instance of Relacion based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Relacion" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Relacion".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						RelacionSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as RelacionSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Relacion based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Relacion.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Relacion, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Relacion.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Relacion.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Relacion instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Relacion instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Relacion instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Relacion instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Relacion instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Relacion instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Relacion instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			Relacion instanceOfRelacion = element as Relacion;
			global::System.Diagnostics.Debug.Assert(instanceOfRelacion != null, "Expecting an instance of Relacion");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfRelacion.Nombre;
				if (!serializationContext.Result.Failed)
				{
					DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nombre", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Relacion instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			Relacion instance = element as Relacion;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Relacion!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Relacion instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, Relacion element, global::System.Xml.XmlWriter writer)
		{
			// RelacionReferenciasTabla
			global::System.Collections.ObjectModel.ReadOnlyCollection<RelacionReferenciasTabla> allRelacionReferenciasTablaInstances = RelacionReferenciasTabla.GetLinksToTabla(element);
			if (!serializationContext.Result.Failed && allRelacionReferenciasTablaInstances.Count > 0)
			{
				writer.WriteStartElement("tabla");
				foreach (RelacionReferenciasTabla eachRelacionReferenciasTablaInstance in allRelacionReferenciasTablaInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachRelacionReferenciasTablaInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachRelacionReferenciasTablaInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachRelacionReferenciasTablaInstance, writer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Relacion instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Relacion instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Relacion instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Relacion instance = element as Relacion;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Relacion!");
	
			string key = instance.Nombre;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Relacion instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Relacion instance = element as Relacion;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Relacion!");
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer TriggerSerializer for DomainClass Trigger.
	/// </summary>
	public partial class TriggerSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// TriggerSerializer Constructor
		/// </summary>
		public TriggerSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Trigger.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"trigger"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Trigger.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerTrigger"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Trigger in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nombre"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Trigger instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Trigger element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Trigger instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Trigger instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			Trigger instanceOfTrigger = element as Trigger;
			global::System.Diagnostics.Debug.Assert(instanceOfTrigger != null, "Expecting an instance of Trigger");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				string attribNombre = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nombre");
				if (attribNombre != null)
				{
					global::System.String valueOfNombre;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNombre, out valueOfNombre))
					{
						instanceOfTrigger.Nombre = valueOfNombre;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nombre", typeof(global::System.String), attribNombre);
					}
				}
			}
			// SQL
			if (!serializationContext.Result.Failed)
			{
				string attribSQL = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sQL");
				if (attribSQL != null)
				{
					global::System.String valueOfSQL;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSQL, out valueOfSQL))
					{
						instanceOfTrigger.SQL = valueOfSQL;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sQL", typeof(global::System.String), attribSQL);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Trigger instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			Trigger instanceOfTrigger = element as Trigger;
			global::System.Diagnostics.Debug.Assert(instanceOfTrigger != null, "Expecting an instance of Trigger!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfTrigger, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory Trigger instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, Trigger element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "evento":	// Relationship "TriggerTieneEvento"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <evento>
							ReadTriggerTieneEventoInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </evento>
						}
						break;
					case "tabla":	// Relationship "TriggerReferenciasTabla"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <tabla>
							ReadTriggerReferenciasTablaInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </tabla>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship TriggerTieneEvento.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Trigger instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadTriggerTieneEventoInstances(DslModeling::SerializationContext serializationContext, Trigger element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newTriggerTieneEventoSerializer = serializationContext.Directory.GetSerializer(TriggerTieneEvento.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newTriggerTieneEventoSerializer != null, "Cannot find serializer for TriggerTieneEvento!");
				TriggerTieneEvento newTriggerTieneEvento = newTriggerTieneEventoSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as TriggerTieneEvento;
				if (newTriggerTieneEvento != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newTriggerTieneEvento, TriggerTieneEvento.TriggerDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newTriggerTieneEvento.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newTriggerTieneEvento.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newTriggerTieneEvento, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newEventoOfTriggerTieneEventoSerializer = serializationContext.Directory.GetSerializer(Evento.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newEventoOfTriggerTieneEventoSerializer != null, "Cannot find serializer for Evento!");
					Evento newEventoOfTriggerTieneEvento = newEventoOfTriggerTieneEventoSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Evento;
					if (newEventoOfTriggerTieneEvento != null)
					{
						DBSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(TriggerTieneEvento));
						element.Evento.Add(newEventoOfTriggerTieneEvento);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newEventoOfTriggerTieneEvento.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newEventoOfTriggerTieneEvento.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newEventoOfTriggerTieneEvento, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship TriggerReferenciasTabla.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Trigger instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadTriggerReferenciasTablaInstances(DslModeling::SerializationContext serializationContext, Trigger element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newTriggerReferenciasTablaSerializer = serializationContext.Directory.GetSerializer(TriggerReferenciasTabla.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newTriggerReferenciasTablaSerializer != null, "Cannot find serializer for TriggerReferenciasTabla!");
				TriggerReferenciasTabla newTriggerReferenciasTabla = newTriggerReferenciasTablaSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as TriggerReferenciasTabla;
				if (newTriggerReferenciasTabla != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newTriggerReferenciasTabla, TriggerReferenciasTabla.TriggerDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newTriggerReferenciasTabla.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newTriggerReferenciasTabla.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newTriggerReferenciasTabla, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newTablaMonikerOfTriggerReferenciasTablaSerializer = serializationContext.Directory.GetSerializer(Tabla.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newTablaMonikerOfTriggerReferenciasTablaSerializer != null, "Cannot find serializer for Tabla!");
					DslModeling::Moniker newTablaMonikerOfTriggerReferenciasTabla = newTablaMonikerOfTriggerReferenciasTablaSerializer.TryCreateMonikerInstance(serializationContext, reader, element, TriggerReferenciasTabla.DomainClassId, element.Partition);
					if (newTablaMonikerOfTriggerReferenciasTabla != null)
					{
						DBSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(TriggerReferenciasTabla));
						new TriggerReferenciasTabla(element.Partition, new DslModeling::RoleAssignment(TriggerReferenciasTabla.TriggerDomainRoleId, element), new DslModeling::RoleAssignment(TriggerReferenciasTabla.TablaDomainRoleId, newTablaMonikerOfTriggerReferenciasTabla));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Trigger based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Trigger, a new Trigger instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Trigger instance, or null if the reader is not pointing to a serialized Trigger instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Trigger" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Trigger".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						TriggerSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TriggerSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Trigger based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Trigger.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Trigger instance should be created.</param>	
		/// <returns>Created Trigger instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Trigger(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Trigger, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Trigger.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Trigger.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Trigger itself) instance of Trigger based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Trigger" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Trigger".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TriggerSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TriggerSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Trigger based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Trigger.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Trigger, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Trigger.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Trigger.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Trigger instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Trigger instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Trigger instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Trigger instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Trigger instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Trigger instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Trigger instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			Trigger instanceOfTrigger = element as Trigger;
			global::System.Diagnostics.Debug.Assert(instanceOfTrigger != null, "Expecting an instance of Trigger");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfTrigger.Nombre;
				if (!serializationContext.Result.Failed)
				{
					DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nombre", propValue);
				}
			}
			// SQL
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfTrigger.SQL;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sQL", propValue);
	
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Trigger instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			Trigger instance = element as Trigger;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Trigger!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Trigger instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, Trigger element, global::System.Xml.XmlWriter writer)
		{
			// TriggerTieneEvento
			global::System.Collections.ObjectModel.ReadOnlyCollection<TriggerTieneEvento> allTriggerTieneEventoInstances = TriggerTieneEvento.GetLinksToEvento(element);
			if (!serializationContext.Result.Failed && allTriggerTieneEventoInstances.Count > 0)
			{
				writer.WriteStartElement("evento");
				foreach (TriggerTieneEvento eachTriggerTieneEventoInstance in allTriggerTieneEventoInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachTriggerTieneEventoInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachTriggerTieneEventoInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachTriggerTieneEventoInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// TriggerReferenciasTabla
			global::System.Collections.ObjectModel.ReadOnlyCollection<TriggerReferenciasTabla> allTriggerReferenciasTablaInstances = TriggerReferenciasTabla.GetLinksToTabla(element);
			if (!serializationContext.Result.Failed && allTriggerReferenciasTablaInstances.Count > 0)
			{
				writer.WriteStartElement("tabla");
				foreach (TriggerReferenciasTabla eachTriggerReferenciasTablaInstance in allTriggerReferenciasTablaInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachTriggerReferenciasTablaInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachTriggerReferenciasTablaInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachTriggerReferenciasTablaInstance, writer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Trigger instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Trigger instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Trigger instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Trigger instance = element as Trigger;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Trigger!");
	
			string key = instance.Nombre;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Trigger instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Trigger instance = element as Trigger;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Trigger!");
			DslModeling::ModelElement container = instance.DBModel;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer EventoSerializer for DomainClass Evento.
	/// </summary>
	public partial class EventoSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// EventoSerializer Constructor
		/// </summary>
		public EventoSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Evento.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"evento"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Evento.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerEvento"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Evento in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nombre"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Evento instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Evento element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Evento instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Evento instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			Evento instanceOfEvento = element as Evento;
			global::System.Diagnostics.Debug.Assert(instanceOfEvento != null, "Expecting an instance of Evento");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				string attribNombre = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nombre");
				if (attribNombre != null)
				{
					global::System.String valueOfNombre;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNombre, out valueOfNombre))
					{
						instanceOfEvento.Nombre = valueOfNombre;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nombre", typeof(global::System.String), attribNombre);
					}
				}
			}
			// Tipo
			if (!serializationContext.Result.Failed)
			{
				string attribTipo = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "tipo");
				if (attribTipo != null)
				{
					global::System.String valueOfTipo;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTipo, out valueOfTipo))
					{
						instanceOfEvento.Tipo = valueOfTipo;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "tipo", typeof(global::System.String), attribTipo);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Evento instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Evento based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Evento, a new Evento instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Evento instance, or null if the reader is not pointing to a serialized Evento instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Evento" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Evento".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						EventoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EventoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Evento based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Evento.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Evento instance should be created.</param>	
		/// <returns>Created Evento instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Evento(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Evento, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Evento.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Evento.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Evento itself) instance of Evento based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Evento" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Evento".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EventoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EventoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Evento based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Evento.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Evento, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Evento.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Evento.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Evento instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Evento instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Evento instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Evento instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Evento instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Evento instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Evento instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			Evento instanceOfEvento = element as Evento;
			global::System.Diagnostics.Debug.Assert(instanceOfEvento != null, "Expecting an instance of Evento");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEvento.Nombre;
				if (!serializationContext.Result.Failed)
				{
					DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nombre", propValue);
				}
			}
			// Tipo
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfEvento.Tipo;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "tipo", propValue);
	
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Evento instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Evento instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Evento instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Evento instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Evento instance = element as Evento;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Evento!");
	
			string key = instance.Nombre;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.Trigger;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Evento instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Evento instance = element as Evento;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Evento!");
			DslModeling::ModelElement container = instance.Trigger;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer ExampleModelHasElementsSerializer for DomainClass ExampleModelHasElements.
	/// </summary>
	public partial class ExampleModelHasElementsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ExampleModelHasElementsSerializer Constructor
		/// </summary>
		public ExampleModelHasElementsSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ExampleModelHasElements.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleModelHasElements"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ExampleModelHasElements.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleModelHasElementsMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ExampleModelHasElements in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ExampleModelHasElements instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ExampleModelHasElements element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleModelHasElements instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Element
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Element.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ExampleModelHasElements");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleModelHasElements instance that will link to the target ExampleElement instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Element
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ExampleElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ExampleElement!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ExampleModelHasElements.ElementDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ExampleModelHasElements");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleModelHasElements instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleModelHasElements instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ExampleModelHasElements based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ExampleModelHasElements, a new ExampleModelHasElements instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ExampleModelHasElements instance, or null if the reader is not pointing to a serialized ExampleModelHasElements instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ExampleModelHasElements based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ExampleModelHasElements type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ExampleModelHasElements, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ExampleModelHasElements" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ExampleModelHasElements".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ExampleModelHasElementsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ExampleModelHasElementsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ExampleModelHasElements based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ExampleModelHasElements.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ExampleModelHasElements instance should be created.</param>	
		/// <returns>Created ExampleModelHasElements instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new ExampleModelHasElements(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ExampleModelHasElements.DBModelDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ExampleModelHasElements.ElementDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ExampleModelHasElements, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ExampleModelHasElements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ExampleModelHasElements.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ExampleModelHasElements itself) instance of ExampleModelHasElements based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ExampleModelHasElements" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ExampleModelHasElements".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ExampleModelHasElementsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ExampleModelHasElementsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ExampleModelHasElements based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ExampleModelHasElements.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ExampleModelHasElements, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ExampleModelHasElements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ExampleModelHasElements.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ExampleModelHasElements instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleModelHasElements instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ExampleModelHasElements instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ExampleModelHasElements instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ExampleModelHasElements instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleModelHasElements instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleModelHasElements instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleModelHasElements instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ExampleModelHasElements instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ExampleModelHasElements instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ExampleModelHasElements instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ExampleModelHasElements instance = element as ExampleModelHasElements;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ExampleModelHasElements!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ExampleModelHasElements instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer ExampleElementReferencesTargetsSerializer for DomainClass ExampleElementReferencesTargets.
	/// </summary>
	public partial class ExampleElementReferencesTargetsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ExampleElementReferencesTargetsSerializer Constructor
		/// </summary>
		public ExampleElementReferencesTargetsSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ExampleElementReferencesTargets.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleElementReferencesTargets"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ExampleElementReferencesTargets.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleElementReferencesTargetsMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ExampleElementReferencesTargets in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ExampleElementReferencesTargets instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ExampleElementReferencesTargets element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleElementReferencesTargets instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the monikerized instance of target role-player Target
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Target.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ExampleElementReferencesTargets");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Target.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleElementReferencesTargets instance that will link to the target ExampleElement instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Target
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ExampleElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ExampleElement!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((ExampleElementReferencesTargets)element).Source, ExampleElementReferencesTargets.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, ExampleElementReferencesTargets.TargetDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ExampleElementReferencesTargets");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleElementReferencesTargets instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleElementReferencesTargets instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ExampleElementReferencesTargets based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ExampleElementReferencesTargets, a new ExampleElementReferencesTargets instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ExampleElementReferencesTargets instance, or null if the reader is not pointing to a serialized ExampleElementReferencesTargets instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ExampleElementReferencesTargets based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ExampleElementReferencesTargets type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ExampleElementReferencesTargets, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ExampleElementReferencesTargets" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ExampleElementReferencesTargets".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ExampleElementReferencesTargetsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ExampleElementReferencesTargetsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ExampleElementReferencesTargets based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ExampleElementReferencesTargets.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ExampleElementReferencesTargets instance should be created.</param>	
		/// <returns>Created ExampleElementReferencesTargets instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new ExampleElementReferencesTargets(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ExampleElementReferencesTargets.SourceDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ExampleElementReferencesTargets.TargetDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ExampleElementReferencesTargets, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ExampleElementReferencesTargets.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ExampleElementReferencesTargets.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ExampleElementReferencesTargets itself) instance of ExampleElementReferencesTargets based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ExampleElementReferencesTargets" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ExampleElementReferencesTargets".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ExampleElementReferencesTargetsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ExampleElementReferencesTargetsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ExampleElementReferencesTargets based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ExampleElementReferencesTargets.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ExampleElementReferencesTargets, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ExampleElementReferencesTargets.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ExampleElementReferencesTargets.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ExampleElementReferencesTargets instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleElementReferencesTargets instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ExampleElementReferencesTargets instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ExampleElementReferencesTargets instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ExampleElementReferencesTargets instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleElementReferencesTargets instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleElementReferencesTargets instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleElementReferencesTargets instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ExampleElementReferencesTargets instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ExampleElementReferencesTargets instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ExampleElementReferencesTargets instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ExampleElementReferencesTargets instance = element as ExampleElementReferencesTargets;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ExampleElementReferencesTargets!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ExampleElementReferencesTargets instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ExampleElement
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ExampleElement that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ExampleElement</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ExampleElement instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ExampleElement, "Expecting an instance of ExampleElement!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, ExampleElementReferencesTargets.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), ExampleElementReferencesTargets.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ExampleElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ExampleElement, "Expecting an instance of ExampleElement!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ExampleElement, "Expecting an instance of ExampleElement!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer DBModelTieneTablaSerializer for DomainClass DBModelTieneTabla.
	/// </summary>
	public partial class DBModelTieneTablaSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// DBModelTieneTablaSerializer Constructor
		/// </summary>
		public DBModelTieneTablaSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of DBModelTieneTabla.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"dBModelTieneTabla"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of DBModelTieneTabla.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"DBModelTieneTabla"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of DBModelTieneTabla in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one DBModelTieneTabla instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the DBModelTieneTabla element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneTabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Tabla
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Tabla.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "DBModelTieneTabla");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Tabla.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneTabla instance that will link to the target Tabla instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Tabla
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Tabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Tabla!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, DBModelTieneTabla.TablaDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "DBModelTieneTabla");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneTabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneTabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of DBModelTieneTabla based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized DBModelTieneTabla, a new DBModelTieneTabla instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created DBModelTieneTabla instance, or null if the reader is not pointing to a serialized DBModelTieneTabla instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of DBModelTieneTabla based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// DBModelTieneTabla type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from DBModelTieneTabla, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModelTieneTabla" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "DBModelTieneTabla".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						DBModelTieneTablaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelTieneTablaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of DBModelTieneTabla based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of DBModelTieneTabla.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new DBModelTieneTabla instance should be created.</param>	
		/// <returns>Created DBModelTieneTabla instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new DBModelTieneTabla(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (DBModelTieneTabla.DBModelDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (DBModelTieneTabla.TablaDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from DBModelTieneTabla, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from DBModelTieneTabla.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModelTieneTabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including DBModelTieneTabla itself) instance of DBModelTieneTabla based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModelTieneTabla" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "DBModelTieneTabla".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						DBModelTieneTablaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelTieneTablaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of DBModelTieneTabla based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, DBModelTieneTabla.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModelTieneTabla, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModelTieneTabla.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModelTieneTabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized DBModelTieneTabla instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneTabla instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the DBModelTieneTabla instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the DBModelTieneTabla instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one DBModelTieneTabla instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneTabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			DBModelTieneTabla instance = element as DBModelTieneTabla;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModelTieneTabla!");
	
			DslModeling::ModelElement targetElement = instance.Tabla;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneTabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneTabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given DBModelTieneTabla instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModelTieneTabla instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the DBModelTieneTabla instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			DBModelTieneTabla instance = element as DBModelTieneTabla;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModelTieneTabla!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModelTieneTabla instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer DBModelTieneVistaSerializer for DomainClass DBModelTieneVista.
	/// </summary>
	public partial class DBModelTieneVistaSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// DBModelTieneVistaSerializer Constructor
		/// </summary>
		public DBModelTieneVistaSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of DBModelTieneVista.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"dBModelTieneVista"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of DBModelTieneVista.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"DBModelTieneVista"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of DBModelTieneVista in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one DBModelTieneVista instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the DBModelTieneVista element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneVista instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Vista
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Vista.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "DBModelTieneVista");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Vista.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneVista instance that will link to the target Vista instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Vista
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Vista.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Vista!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, DBModelTieneVista.VistaDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "DBModelTieneVista");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneVista instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneVista instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of DBModelTieneVista based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized DBModelTieneVista, a new DBModelTieneVista instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created DBModelTieneVista instance, or null if the reader is not pointing to a serialized DBModelTieneVista instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of DBModelTieneVista based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// DBModelTieneVista type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from DBModelTieneVista, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModelTieneVista" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "DBModelTieneVista".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						DBModelTieneVistaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelTieneVistaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of DBModelTieneVista based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of DBModelTieneVista.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new DBModelTieneVista instance should be created.</param>	
		/// <returns>Created DBModelTieneVista instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new DBModelTieneVista(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (DBModelTieneVista.DBModelDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (DBModelTieneVista.VistaDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from DBModelTieneVista, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from DBModelTieneVista.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModelTieneVista.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including DBModelTieneVista itself) instance of DBModelTieneVista based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModelTieneVista" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "DBModelTieneVista".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						DBModelTieneVistaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelTieneVistaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of DBModelTieneVista based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, DBModelTieneVista.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModelTieneVista, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModelTieneVista.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModelTieneVista.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized DBModelTieneVista instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneVista instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the DBModelTieneVista instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the DBModelTieneVista instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one DBModelTieneVista instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneVista instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			DBModelTieneVista instance = element as DBModelTieneVista;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModelTieneVista!");
	
			DslModeling::ModelElement targetElement = instance.Vista;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneVista instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneVista instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given DBModelTieneVista instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModelTieneVista instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the DBModelTieneVista instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			DBModelTieneVista instance = element as DBModelTieneVista;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModelTieneVista!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModelTieneVista instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer DBModelTieneProcedimientoAlmacenadoSerializer for DomainClass DBModelTieneProcedimientoAlmacenado.
	/// </summary>
	public partial class DBModelTieneProcedimientoAlmacenadoSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// DBModelTieneProcedimientoAlmacenadoSerializer Constructor
		/// </summary>
		public DBModelTieneProcedimientoAlmacenadoSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of DBModelTieneProcedimientoAlmacenado.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"dBModelTieneProcedimientoAlmacenado"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of DBModelTieneProcedimientoAlmacenado.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"DBModelTieneProcedimientoAlmacenado"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of DBModelTieneProcedimientoAlmacenado in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one DBModelTieneProcedimientoAlmacenado instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the DBModelTieneProcedimientoAlmacenado element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneProcedimientoAlmacenado instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player ProcedimientoAlmacenado
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player ProcedimientoAlmacenado.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "DBModelTieneProcedimientoAlmacenado");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player ProcedimientoAlmacenado.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneProcedimientoAlmacenado instance that will link to the target ProcedimientoAlmacenado instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player ProcedimientoAlmacenado
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ProcedimientoAlmacenado.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ProcedimientoAlmacenado!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, DBModelTieneProcedimientoAlmacenado.ProcedimientoAlmacenadoDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "DBModelTieneProcedimientoAlmacenado");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneProcedimientoAlmacenado instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneProcedimientoAlmacenado instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of DBModelTieneProcedimientoAlmacenado based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized DBModelTieneProcedimientoAlmacenado, a new DBModelTieneProcedimientoAlmacenado instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created DBModelTieneProcedimientoAlmacenado instance, or null if the reader is not pointing to a serialized DBModelTieneProcedimientoAlmacenado instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of DBModelTieneProcedimientoAlmacenado based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// DBModelTieneProcedimientoAlmacenado type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from DBModelTieneProcedimientoAlmacenado, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModelTieneProcedimientoAlmacenado" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "DBModelTieneProcedimientoAlmacenado".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						DBModelTieneProcedimientoAlmacenadoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelTieneProcedimientoAlmacenadoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of DBModelTieneProcedimientoAlmacenado based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of DBModelTieneProcedimientoAlmacenado.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new DBModelTieneProcedimientoAlmacenado instance should be created.</param>	
		/// <returns>Created DBModelTieneProcedimientoAlmacenado instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new DBModelTieneProcedimientoAlmacenado(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (DBModelTieneProcedimientoAlmacenado.DBModelDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (DBModelTieneProcedimientoAlmacenado.ProcedimientoAlmacenadoDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from DBModelTieneProcedimientoAlmacenado, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from DBModelTieneProcedimientoAlmacenado.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModelTieneProcedimientoAlmacenado.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including DBModelTieneProcedimientoAlmacenado itself) instance of DBModelTieneProcedimientoAlmacenado based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModelTieneProcedimientoAlmacenado" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "DBModelTieneProcedimientoAlmacenado".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						DBModelTieneProcedimientoAlmacenadoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelTieneProcedimientoAlmacenadoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of DBModelTieneProcedimientoAlmacenado based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, DBModelTieneProcedimientoAlmacenado.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModelTieneProcedimientoAlmacenado, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModelTieneProcedimientoAlmacenado.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModelTieneProcedimientoAlmacenado.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized DBModelTieneProcedimientoAlmacenado instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneProcedimientoAlmacenado instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the DBModelTieneProcedimientoAlmacenado instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the DBModelTieneProcedimientoAlmacenado instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one DBModelTieneProcedimientoAlmacenado instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneProcedimientoAlmacenado instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			DBModelTieneProcedimientoAlmacenado instance = element as DBModelTieneProcedimientoAlmacenado;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModelTieneProcedimientoAlmacenado!");
	
			DslModeling::ModelElement targetElement = instance.ProcedimientoAlmacenado;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneProcedimientoAlmacenado instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneProcedimientoAlmacenado instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given DBModelTieneProcedimientoAlmacenado instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModelTieneProcedimientoAlmacenado instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the DBModelTieneProcedimientoAlmacenado instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			DBModelTieneProcedimientoAlmacenado instance = element as DBModelTieneProcedimientoAlmacenado;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModelTieneProcedimientoAlmacenado!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModelTieneProcedimientoAlmacenado instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer TablaTieneCampoSerializer for DomainClass TablaTieneCampo.
	/// </summary>
	public partial class TablaTieneCampoSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// TablaTieneCampoSerializer Constructor
		/// </summary>
		public TablaTieneCampoSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TablaTieneCampo.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"tablaTieneCampo"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of TablaTieneCampo.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerTablaTieneCampo"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of TablaTieneCampo in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TablaTieneCampo instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TablaTieneCampo element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaTieneCampo instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Campo
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Campo.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TablaTieneCampo");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Campo.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaTieneCampo instance that will link to the target Campo instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Campo
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Campo.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Campo!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, TablaTieneCampo.CampoDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TablaTieneCampo");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaTieneCampo instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaTieneCampo instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of TablaTieneCampo based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TablaTieneCampo, a new TablaTieneCampo instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TablaTieneCampo instance, or null if the reader is not pointing to a serialized TablaTieneCampo instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of TablaTieneCampo based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// TablaTieneCampo type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from TablaTieneCampo, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TablaTieneCampo" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TablaTieneCampo".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						TablaTieneCampoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TablaTieneCampoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TablaTieneCampo based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TablaTieneCampo.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TablaTieneCampo instance should be created.</param>	
		/// <returns>Created TablaTieneCampo instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new TablaTieneCampo(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TablaTieneCampo.TablaDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TablaTieneCampo.CampoDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TablaTieneCampo, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TablaTieneCampo.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TablaTieneCampo.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TablaTieneCampo itself) instance of TablaTieneCampo based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TablaTieneCampo" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TablaTieneCampo".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TablaTieneCampoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TablaTieneCampoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TablaTieneCampo based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, TablaTieneCampo.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TablaTieneCampo, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TablaTieneCampo.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TablaTieneCampo.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TablaTieneCampo instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaTieneCampo instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TablaTieneCampo instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TablaTieneCampo instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one TablaTieneCampo instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaTieneCampo instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			TablaTieneCampo instance = element as TablaTieneCampo;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TablaTieneCampo!");
	
			DslModeling::ModelElement targetElement = instance.Campo;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaTieneCampo instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaTieneCampo instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TablaTieneCampo instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TablaTieneCampo instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TablaTieneCampo instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TablaTieneCampo instance = element as TablaTieneCampo;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TablaTieneCampo!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TablaTieneCampo instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer TablaTieneClavePrimariaSerializer for DomainClass TablaTieneClavePrimaria.
	/// </summary>
	public partial class TablaTieneClavePrimariaSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// TablaTieneClavePrimariaSerializer Constructor
		/// </summary>
		public TablaTieneClavePrimariaSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TablaTieneClavePrimaria.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"tablaTieneClavePrimaria"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of TablaTieneClavePrimaria.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerTablaTieneClavePrimaria"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of TablaTieneClavePrimaria in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TablaTieneClavePrimaria instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TablaTieneClavePrimaria element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaTieneClavePrimaria instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player ClavePrimaria
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player ClavePrimaria.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TablaTieneClavePrimaria");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player ClavePrimaria.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaTieneClavePrimaria instance that will link to the target ClavePrimaria instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player ClavePrimaria
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ClavePrimaria.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ClavePrimaria!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, TablaTieneClavePrimaria.ClavePrimariaDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TablaTieneClavePrimaria");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaTieneClavePrimaria instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaTieneClavePrimaria instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of TablaTieneClavePrimaria based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TablaTieneClavePrimaria, a new TablaTieneClavePrimaria instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TablaTieneClavePrimaria instance, or null if the reader is not pointing to a serialized TablaTieneClavePrimaria instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of TablaTieneClavePrimaria based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// TablaTieneClavePrimaria type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from TablaTieneClavePrimaria, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TablaTieneClavePrimaria" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TablaTieneClavePrimaria".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						TablaTieneClavePrimariaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TablaTieneClavePrimariaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TablaTieneClavePrimaria based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TablaTieneClavePrimaria.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TablaTieneClavePrimaria instance should be created.</param>	
		/// <returns>Created TablaTieneClavePrimaria instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new TablaTieneClavePrimaria(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TablaTieneClavePrimaria.TablaDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TablaTieneClavePrimaria.ClavePrimariaDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TablaTieneClavePrimaria, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TablaTieneClavePrimaria.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TablaTieneClavePrimaria.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TablaTieneClavePrimaria itself) instance of TablaTieneClavePrimaria based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TablaTieneClavePrimaria" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TablaTieneClavePrimaria".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TablaTieneClavePrimariaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TablaTieneClavePrimariaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TablaTieneClavePrimaria based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, TablaTieneClavePrimaria.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TablaTieneClavePrimaria, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TablaTieneClavePrimaria.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TablaTieneClavePrimaria.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TablaTieneClavePrimaria instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaTieneClavePrimaria instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TablaTieneClavePrimaria instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TablaTieneClavePrimaria instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one TablaTieneClavePrimaria instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaTieneClavePrimaria instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			TablaTieneClavePrimaria instance = element as TablaTieneClavePrimaria;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TablaTieneClavePrimaria!");
	
			DslModeling::ModelElement targetElement = instance.ClavePrimaria;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaTieneClavePrimaria instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaTieneClavePrimaria instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TablaTieneClavePrimaria instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TablaTieneClavePrimaria instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TablaTieneClavePrimaria instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TablaTieneClavePrimaria instance = element as TablaTieneClavePrimaria;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TablaTieneClavePrimaria!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TablaTieneClavePrimaria instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer DBModelTieneRelacionSerializer for DomainClass DBModelTieneRelacion.
	/// </summary>
	public partial class DBModelTieneRelacionSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// DBModelTieneRelacionSerializer Constructor
		/// </summary>
		public DBModelTieneRelacionSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of DBModelTieneRelacion.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"dBModelTieneRelacion"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of DBModelTieneRelacion.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerDBModelTieneRelacion"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of DBModelTieneRelacion in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one DBModelTieneRelacion instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the DBModelTieneRelacion element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneRelacion instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Relacion
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Relacion.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "DBModelTieneRelacion");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Relacion.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneRelacion instance that will link to the target Relacion instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Relacion
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Relacion.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Relacion!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, DBModelTieneRelacion.RelacionDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "DBModelTieneRelacion");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneRelacion instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneRelacion instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of DBModelTieneRelacion based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized DBModelTieneRelacion, a new DBModelTieneRelacion instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created DBModelTieneRelacion instance, or null if the reader is not pointing to a serialized DBModelTieneRelacion instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of DBModelTieneRelacion based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// DBModelTieneRelacion type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from DBModelTieneRelacion, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModelTieneRelacion" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "DBModelTieneRelacion".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						DBModelTieneRelacionSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelTieneRelacionSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of DBModelTieneRelacion based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of DBModelTieneRelacion.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new DBModelTieneRelacion instance should be created.</param>	
		/// <returns>Created DBModelTieneRelacion instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new DBModelTieneRelacion(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (DBModelTieneRelacion.DBModelDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (DBModelTieneRelacion.RelacionDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from DBModelTieneRelacion, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from DBModelTieneRelacion.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModelTieneRelacion.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including DBModelTieneRelacion itself) instance of DBModelTieneRelacion based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModelTieneRelacion" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "DBModelTieneRelacion".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						DBModelTieneRelacionSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelTieneRelacionSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of DBModelTieneRelacion based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, DBModelTieneRelacion.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModelTieneRelacion, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModelTieneRelacion.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModelTieneRelacion.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized DBModelTieneRelacion instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneRelacion instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the DBModelTieneRelacion instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the DBModelTieneRelacion instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one DBModelTieneRelacion instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneRelacion instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			DBModelTieneRelacion instance = element as DBModelTieneRelacion;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModelTieneRelacion!");
	
			DslModeling::ModelElement targetElement = instance.Relacion;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneRelacion instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneRelacion instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given DBModelTieneRelacion instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModelTieneRelacion instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the DBModelTieneRelacion instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			DBModelTieneRelacion instance = element as DBModelTieneRelacion;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModelTieneRelacion!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModelTieneRelacion instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer RelacionReferenciasTablaSerializer for DomainClass RelacionReferenciasTabla.
	/// </summary>
	public partial class RelacionReferenciasTablaSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// RelacionReferenciasTablaSerializer Constructor
		/// </summary>
		public RelacionReferenciasTablaSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of RelacionReferenciasTabla.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"relacionReferenciasTabla"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of RelacionReferenciasTabla.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerRelacionReferenciasTabla"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of RelacionReferenciasTabla in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one RelacionReferenciasTabla instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the RelacionReferenciasTabla element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory RelacionReferenciasTabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the monikerized instance of target role-player Tabla
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Tabla.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "RelacionReferenciasTabla");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Tabla.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory RelacionReferenciasTabla instance that will link to the target Tabla instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Tabla
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Tabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Tabla!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((RelacionReferenciasTabla)element).Relacion, RelacionReferenciasTabla.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, RelacionReferenciasTabla.TablaDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "RelacionReferenciasTabla");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory RelacionReferenciasTabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory RelacionReferenciasTabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of RelacionReferenciasTabla based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized RelacionReferenciasTabla, a new RelacionReferenciasTabla instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created RelacionReferenciasTabla instance, or null if the reader is not pointing to a serialized RelacionReferenciasTabla instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of RelacionReferenciasTabla based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// RelacionReferenciasTabla type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from RelacionReferenciasTabla, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "RelacionReferenciasTabla" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "RelacionReferenciasTabla".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						RelacionReferenciasTablaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as RelacionReferenciasTablaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of RelacionReferenciasTabla based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of RelacionReferenciasTabla.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new RelacionReferenciasTabla instance should be created.</param>	
		/// <returns>Created RelacionReferenciasTabla instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new RelacionReferenciasTabla(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (RelacionReferenciasTabla.RelacionDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (RelacionReferenciasTabla.TablaDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from RelacionReferenciasTabla, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from RelacionReferenciasTabla.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(RelacionReferenciasTabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including RelacionReferenciasTabla itself) instance of RelacionReferenciasTabla based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "RelacionReferenciasTabla" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "RelacionReferenciasTabla".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						RelacionReferenciasTablaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as RelacionReferenciasTablaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of RelacionReferenciasTabla based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, RelacionReferenciasTabla.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from RelacionReferenciasTabla, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from RelacionReferenciasTabla.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(RelacionReferenciasTabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized RelacionReferenciasTabla instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">RelacionReferenciasTabla instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the RelacionReferenciasTabla instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the RelacionReferenciasTabla instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one RelacionReferenciasTabla instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">RelacionReferenciasTabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			RelacionReferenciasTabla instance = element as RelacionReferenciasTabla;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of RelacionReferenciasTabla!");
	
			DslModeling::ModelElement targetElement = instance.Tabla;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Relacion, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">RelacionReferenciasTabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">RelacionReferenciasTabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given RelacionReferenciasTabla instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">RelacionReferenciasTabla instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the RelacionReferenciasTabla instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			RelacionReferenciasTabla instance = element as RelacionReferenciasTabla;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of RelacionReferenciasTabla!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">RelacionReferenciasTabla instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a Tabla
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of Relacion that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of Tabla</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of Tabla instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Relacion, "Expecting an instance of Relacion!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, RelacionReferenciasTabla.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), RelacionReferenciasTabla.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a Tabla.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Relacion, "Expecting an instance of Relacion!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is Tabla, "Expecting an instance of Tabla!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer TriggerTieneEventoSerializer for DomainClass TriggerTieneEvento.
	/// </summary>
	public partial class TriggerTieneEventoSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// TriggerTieneEventoSerializer Constructor
		/// </summary>
		public TriggerTieneEventoSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TriggerTieneEvento.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"triggerTieneEvento"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of TriggerTieneEvento.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerTriggerTieneEvento"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of TriggerTieneEvento in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TriggerTieneEvento instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TriggerTieneEvento element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TriggerTieneEvento instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Evento
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Evento.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TriggerTieneEvento");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Evento.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TriggerTieneEvento instance that will link to the target Evento instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Evento
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Evento.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Evento!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, TriggerTieneEvento.EventoDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TriggerTieneEvento");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TriggerTieneEvento instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TriggerTieneEvento instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of TriggerTieneEvento based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TriggerTieneEvento, a new TriggerTieneEvento instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TriggerTieneEvento instance, or null if the reader is not pointing to a serialized TriggerTieneEvento instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of TriggerTieneEvento based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// TriggerTieneEvento type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from TriggerTieneEvento, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TriggerTieneEvento" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TriggerTieneEvento".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						TriggerTieneEventoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TriggerTieneEventoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TriggerTieneEvento based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TriggerTieneEvento.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TriggerTieneEvento instance should be created.</param>	
		/// <returns>Created TriggerTieneEvento instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new TriggerTieneEvento(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TriggerTieneEvento.TriggerDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TriggerTieneEvento.EventoDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TriggerTieneEvento, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TriggerTieneEvento.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TriggerTieneEvento.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TriggerTieneEvento itself) instance of TriggerTieneEvento based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TriggerTieneEvento" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TriggerTieneEvento".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TriggerTieneEventoSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TriggerTieneEventoSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TriggerTieneEvento based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, TriggerTieneEvento.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TriggerTieneEvento, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TriggerTieneEvento.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TriggerTieneEvento.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TriggerTieneEvento instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerTieneEvento instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TriggerTieneEvento instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TriggerTieneEvento instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one TriggerTieneEvento instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerTieneEvento instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			TriggerTieneEvento instance = element as TriggerTieneEvento;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TriggerTieneEvento!");
	
			DslModeling::ModelElement targetElement = instance.Evento;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerTieneEvento instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerTieneEvento instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TriggerTieneEvento instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TriggerTieneEvento instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TriggerTieneEvento instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TriggerTieneEvento instance = element as TriggerTieneEvento;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TriggerTieneEvento!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TriggerTieneEvento instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer TriggerReferenciasTablaSerializer for DomainClass TriggerReferenciasTabla.
	/// </summary>
	public partial class TriggerReferenciasTablaSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// TriggerReferenciasTablaSerializer Constructor
		/// </summary>
		public TriggerReferenciasTablaSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TriggerReferenciasTabla.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"triggerReferenciasTabla"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of TriggerReferenciasTabla.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerTriggerReferenciasTabla"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of TriggerReferenciasTabla in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TriggerReferenciasTabla instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TriggerReferenciasTabla element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TriggerReferenciasTabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the monikerized instance of target role-player Tabla
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Tabla.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TriggerReferenciasTabla");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Tabla.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TriggerReferenciasTabla instance that will link to the target Tabla instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Tabla
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Tabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Tabla!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((TriggerReferenciasTabla)element).Trigger, TriggerReferenciasTabla.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, TriggerReferenciasTabla.TablaDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TriggerReferenciasTabla");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TriggerReferenciasTabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TriggerReferenciasTabla instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of TriggerReferenciasTabla based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TriggerReferenciasTabla, a new TriggerReferenciasTabla instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TriggerReferenciasTabla instance, or null if the reader is not pointing to a serialized TriggerReferenciasTabla instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of TriggerReferenciasTabla based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// TriggerReferenciasTabla type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from TriggerReferenciasTabla, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TriggerReferenciasTabla" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TriggerReferenciasTabla".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						TriggerReferenciasTablaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TriggerReferenciasTablaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TriggerReferenciasTabla based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TriggerReferenciasTabla.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TriggerReferenciasTabla instance should be created.</param>	
		/// <returns>Created TriggerReferenciasTabla instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new TriggerReferenciasTabla(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TriggerReferenciasTabla.TriggerDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TriggerReferenciasTabla.TablaDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TriggerReferenciasTabla, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TriggerReferenciasTabla.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TriggerReferenciasTabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TriggerReferenciasTabla itself) instance of TriggerReferenciasTabla based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TriggerReferenciasTabla" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TriggerReferenciasTabla".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TriggerReferenciasTablaSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TriggerReferenciasTablaSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TriggerReferenciasTabla based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, TriggerReferenciasTabla.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TriggerReferenciasTabla, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TriggerReferenciasTabla.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TriggerReferenciasTabla.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TriggerReferenciasTabla instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerReferenciasTabla instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TriggerReferenciasTabla instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TriggerReferenciasTabla instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one TriggerReferenciasTabla instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerReferenciasTabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			TriggerReferenciasTabla instance = element as TriggerReferenciasTabla;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TriggerReferenciasTabla!");
	
			DslModeling::ModelElement targetElement = instance.Tabla;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Trigger, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerReferenciasTabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerReferenciasTabla instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TriggerReferenciasTabla instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TriggerReferenciasTabla instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TriggerReferenciasTabla instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TriggerReferenciasTabla instance = element as TriggerReferenciasTabla;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TriggerReferenciasTabla!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TriggerReferenciasTabla instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a Tabla
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of Trigger that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of Tabla</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of Tabla instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Trigger, "Expecting an instance of Trigger!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, TriggerReferenciasTabla.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), TriggerReferenciasTabla.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a Tabla.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Trigger, "Expecting an instance of Trigger!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is Tabla, "Expecting an instance of Tabla!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer DBModelTieneTriggerSerializer for DomainClass DBModelTieneTrigger.
	/// </summary>
	public partial class DBModelTieneTriggerSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// DBModelTieneTriggerSerializer Constructor
		/// </summary>
		public DBModelTieneTriggerSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of DBModelTieneTrigger.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"dBModelTieneTrigger"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of DBModelTieneTrigger.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerDBModelTieneTrigger"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of DBModelTieneTrigger in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one DBModelTieneTrigger instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the DBModelTieneTrigger element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneTrigger instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Trigger
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Trigger.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "DBModelTieneTrigger");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Trigger.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneTrigger instance that will link to the target Trigger instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Trigger
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Trigger.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Trigger!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, DBModelTieneTrigger.TriggerDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				DBSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "DBModelTieneTrigger");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneTrigger instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBModelTieneTrigger instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of DBModelTieneTrigger based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized DBModelTieneTrigger, a new DBModelTieneTrigger instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created DBModelTieneTrigger instance, or null if the reader is not pointing to a serialized DBModelTieneTrigger instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of DBModelTieneTrigger based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// DBModelTieneTrigger type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from DBModelTieneTrigger, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModelTieneTrigger" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "DBModelTieneTrigger".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						DBModelTieneTriggerSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelTieneTriggerSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of DBModelTieneTrigger based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of DBModelTieneTrigger.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new DBModelTieneTrigger instance should be created.</param>	
		/// <returns>Created DBModelTieneTrigger instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new DBModelTieneTrigger(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (DBModelTieneTrigger.DBModelDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (DBModelTieneTrigger.TriggerDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from DBModelTieneTrigger, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from DBModelTieneTrigger.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModelTieneTrigger.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including DBModelTieneTrigger itself) instance of DBModelTieneTrigger based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBModelTieneTrigger" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "DBModelTieneTrigger".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						DBModelTieneTriggerSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBModelTieneTriggerSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of DBModelTieneTrigger based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, DBModelTieneTrigger.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModelTieneTrigger, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from DBModelTieneTrigger.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBModelTieneTrigger.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized DBModelTieneTrigger instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneTrigger instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the DBModelTieneTrigger instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the DBModelTieneTrigger instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one DBModelTieneTrigger instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneTrigger instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			DBModelTieneTrigger instance = element as DBModelTieneTrigger;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModelTieneTrigger!");
	
			DslModeling::ModelElement targetElement = instance.Trigger;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneTrigger instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBModelTieneTrigger instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given DBModelTieneTrigger instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModelTieneTrigger instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the DBModelTieneTrigger instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			DBModelTieneTrigger instance = element as DBModelTieneTrigger;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBModelTieneTrigger!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBModelTieneTrigger instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer ExampleShapeSerializer for DomainClass ExampleShape.
	/// </summary>
	public partial class ExampleShapeSerializer : DslDiagrams::NodeShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// ExampleShapeSerializer Constructor
		/// </summary>
		public ExampleShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ExampleShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ExampleShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ExampleShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ExampleShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ExampleShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ExampleShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ExampleShape, a new ExampleShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ExampleShape instance, or null if the reader is not pointing to a serialized ExampleShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ExampleShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ExampleShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ExampleShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ExampleShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ExampleShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ExampleShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ExampleShape instance should be created.</param>	
		/// <returns>Created ExampleShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ExampleShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ExampleShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ExampleShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ExampleShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ExampleShape itself) instance of ExampleShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ExampleShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ExampleShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ExampleShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ExampleShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ExampleShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ExampleShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ExampleShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ExampleShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ExampleShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ExampleShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ExampleShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ExampleShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ExampleShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ExampleShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ExampleShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ExampleShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ExampleShape instance = element as ExampleShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ExampleShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ExampleShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer TablaShapeSerializer for DomainClass TablaShape.
	/// </summary>
	public partial class TablaShapeSerializer : DslDiagrams::NodeShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// TablaShapeSerializer Constructor
		/// </summary>
		public TablaShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TablaShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"tablaShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of TablaShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"TablaShape"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of TablaShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TablaShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TablaShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of TablaShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TablaShape, a new TablaShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TablaShape instance, or null if the reader is not pointing to a serialized TablaShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TablaShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TablaShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						TablaShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TablaShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TablaShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TablaShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TablaShape instance should be created.</param>	
		/// <returns>Created TablaShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new TablaShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TablaShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TablaShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TablaShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TablaShape itself) instance of TablaShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TablaShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TablaShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TablaShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TablaShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TablaShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, TablaShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TablaShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TablaShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TablaShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TablaShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TablaShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TablaShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one TablaShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TablaShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TablaShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TablaShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TablaShape instance = element as TablaShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TablaShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TablaShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer ProcedimientoAlmacenadoShapeSerializer for DomainClass ProcedimientoAlmacenadoShape.
	/// </summary>
	public partial class ProcedimientoAlmacenadoShapeSerializer : DslDiagrams::NodeShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// ProcedimientoAlmacenadoShapeSerializer Constructor
		/// </summary>
		public ProcedimientoAlmacenadoShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ProcedimientoAlmacenadoShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"procedimientoAlmacenadoShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ProcedimientoAlmacenadoShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"ProcedimientoAlmacenadoShape"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ProcedimientoAlmacenadoShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ProcedimientoAlmacenadoShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ProcedimientoAlmacenadoShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ProcedimientoAlmacenadoShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ProcedimientoAlmacenadoShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ProcedimientoAlmacenadoShape, a new ProcedimientoAlmacenadoShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ProcedimientoAlmacenadoShape instance, or null if the reader is not pointing to a serialized ProcedimientoAlmacenadoShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ProcedimientoAlmacenadoShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ProcedimientoAlmacenadoShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ProcedimientoAlmacenadoShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ProcedimientoAlmacenadoShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ProcedimientoAlmacenadoShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ProcedimientoAlmacenadoShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ProcedimientoAlmacenadoShape instance should be created.</param>	
		/// <returns>Created ProcedimientoAlmacenadoShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ProcedimientoAlmacenadoShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ProcedimientoAlmacenadoShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ProcedimientoAlmacenadoShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ProcedimientoAlmacenadoShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ProcedimientoAlmacenadoShape itself) instance of ProcedimientoAlmacenadoShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ProcedimientoAlmacenadoShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ProcedimientoAlmacenadoShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ProcedimientoAlmacenadoShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ProcedimientoAlmacenadoShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ProcedimientoAlmacenadoShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ProcedimientoAlmacenadoShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ProcedimientoAlmacenadoShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ProcedimientoAlmacenadoShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ProcedimientoAlmacenadoShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ProcedimientoAlmacenadoShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ProcedimientoAlmacenadoShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ProcedimientoAlmacenadoShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ProcedimientoAlmacenadoShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ProcedimientoAlmacenadoShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ProcedimientoAlmacenadoShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ProcedimientoAlmacenadoShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ProcedimientoAlmacenadoShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ProcedimientoAlmacenadoShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ProcedimientoAlmacenadoShape instance = element as ProcedimientoAlmacenadoShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ProcedimientoAlmacenadoShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ProcedimientoAlmacenadoShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer VistaShapeSerializer for DomainClass VistaShape.
	/// </summary>
	public partial class VistaShapeSerializer : DslDiagrams::NodeShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// VistaShapeSerializer Constructor
		/// </summary>
		public VistaShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of VistaShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"vistaShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of VistaShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"VistaShape"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of VistaShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one VistaShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the VistaShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory VistaShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of VistaShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized VistaShape, a new VistaShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created VistaShape instance, or null if the reader is not pointing to a serialized VistaShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "VistaShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "VistaShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						VistaShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as VistaShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of VistaShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of VistaShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new VistaShape instance should be created.</param>	
		/// <returns>Created VistaShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new VistaShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from VistaShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from VistaShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(VistaShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including VistaShape itself) instance of VistaShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "VistaShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "VistaShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						VistaShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as VistaShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of VistaShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, VistaShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from VistaShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from VistaShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(VistaShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized VistaShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">VistaShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the VistaShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the VistaShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one VistaShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">VistaShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given VistaShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">VistaShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the VistaShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			VistaShape instance = element as VistaShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of VistaShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">VistaShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer RelacionShapeSerializer for DomainClass RelacionShape.
	/// </summary>
	public partial class RelacionShapeSerializer : DslDiagrams::NodeShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// RelacionShapeSerializer Constructor
		/// </summary>
		public RelacionShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of RelacionShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"relacionShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of RelacionShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerRelacionShape"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of RelacionShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one RelacionShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the RelacionShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory RelacionShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of RelacionShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized RelacionShape, a new RelacionShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created RelacionShape instance, or null if the reader is not pointing to a serialized RelacionShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "RelacionShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "RelacionShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						RelacionShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as RelacionShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of RelacionShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of RelacionShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new RelacionShape instance should be created.</param>	
		/// <returns>Created RelacionShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new RelacionShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from RelacionShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from RelacionShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(RelacionShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including RelacionShape itself) instance of RelacionShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "RelacionShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "RelacionShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						RelacionShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as RelacionShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of RelacionShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, RelacionShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from RelacionShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from RelacionShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(RelacionShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized RelacionShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">RelacionShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the RelacionShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the RelacionShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one RelacionShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">RelacionShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given RelacionShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">RelacionShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the RelacionShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			RelacionShape instance = element as RelacionShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of RelacionShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">RelacionShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer EventoShapeSerializer for DomainClass EventoShape.
	/// </summary>
	public partial class EventoShapeSerializer : DslDiagrams::NodeShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// EventoShapeSerializer Constructor
		/// </summary>
		public EventoShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of EventoShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"eventoShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of EventoShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerEventoShape"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of EventoShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one EventoShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the EventoShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EventoShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of EventoShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized EventoShape, a new EventoShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created EventoShape instance, or null if the reader is not pointing to a serialized EventoShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EventoShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "EventoShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						EventoShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EventoShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of EventoShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of EventoShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new EventoShape instance should be created.</param>	
		/// <returns>Created EventoShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new EventoShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from EventoShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from EventoShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EventoShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including EventoShape itself) instance of EventoShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EventoShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "EventoShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EventoShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EventoShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of EventoShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, EventoShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from EventoShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from EventoShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EventoShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized EventoShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EventoShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the EventoShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the EventoShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one EventoShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EventoShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given EventoShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EventoShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the EventoShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EventoShape instance = element as EventoShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EventoShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EventoShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer TablaCompartmentShapeSerializer for DomainClass TablaCompartmentShape.
	/// </summary>
	public partial class TablaCompartmentShapeSerializer : DslDiagrams::CompartmentShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// TablaCompartmentShapeSerializer Constructor
		/// </summary>
		public TablaCompartmentShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TablaCompartmentShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"tablaCompartmentShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of TablaCompartmentShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerCompartmentShape1"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of TablaCompartmentShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TablaCompartmentShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TablaCompartmentShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaCompartmentShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TablaCompartmentShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			TablaCompartmentShape instanceOfTablaCompartmentShape = element as TablaCompartmentShape;
			global::System.Diagnostics.Debug.Assert(instanceOfTablaCompartmentShape != null, "Expecting an instance of TablaCompartmentShape");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				string attribNombre = DBSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "nombre");
				if (attribNombre != null)
				{
					global::System.String valueOfNombre;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNombre, out valueOfNombre))
					{
						instanceOfTablaCompartmentShape.Nombre = valueOfNombre;
					}
					else
					{	// Invalid property value, ignored.
						DBSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nombre", typeof(global::System.String), attribNombre);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of TablaCompartmentShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TablaCompartmentShape, a new TablaCompartmentShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TablaCompartmentShape instance, or null if the reader is not pointing to a serialized TablaCompartmentShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TablaCompartmentShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TablaCompartmentShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						TablaCompartmentShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TablaCompartmentShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TablaCompartmentShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TablaCompartmentShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TablaCompartmentShape instance should be created.</param>	
		/// <returns>Created TablaCompartmentShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new TablaCompartmentShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TablaCompartmentShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TablaCompartmentShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TablaCompartmentShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TablaCompartmentShape itself) instance of TablaCompartmentShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TablaCompartmentShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TablaCompartmentShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TablaCompartmentShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TablaCompartmentShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TablaCompartmentShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, TablaCompartmentShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TablaCompartmentShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TablaCompartmentShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TablaCompartmentShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TablaCompartmentShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaCompartmentShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TablaCompartmentShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TablaCompartmentShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one TablaCompartmentShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaCompartmentShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TablaCompartmentShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			TablaCompartmentShape instanceOfTablaCompartmentShape = element as TablaCompartmentShape;
			global::System.Diagnostics.Debug.Assert(instanceOfTablaCompartmentShape != null, "Expecting an instance of TablaCompartmentShape");
	
			// Nombre
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfTablaCompartmentShape.Nombre;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "nombre", propValue);
	
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TablaCompartmentShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TablaCompartmentShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TablaCompartmentShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TablaCompartmentShape instance = element as TablaCompartmentShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TablaCompartmentShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TablaCompartmentShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer TriggerCompartmentShapeSerializer for DomainClass TriggerCompartmentShape.
	/// </summary>
	public partial class TriggerCompartmentShapeSerializer : DslDiagrams::CompartmentShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// TriggerCompartmentShapeSerializer Constructor
		/// </summary>
		public TriggerCompartmentShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TriggerCompartmentShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"triggerCompartmentShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of TriggerCompartmentShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerTriggerCompartmentShape"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of TriggerCompartmentShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TriggerCompartmentShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TriggerCompartmentShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TriggerCompartmentShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of TriggerCompartmentShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TriggerCompartmentShape, a new TriggerCompartmentShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TriggerCompartmentShape instance, or null if the reader is not pointing to a serialized TriggerCompartmentShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TriggerCompartmentShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TriggerCompartmentShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						TriggerCompartmentShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TriggerCompartmentShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TriggerCompartmentShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TriggerCompartmentShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TriggerCompartmentShape instance should be created.</param>	
		/// <returns>Created TriggerCompartmentShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new TriggerCompartmentShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TriggerCompartmentShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TriggerCompartmentShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TriggerCompartmentShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TriggerCompartmentShape itself) instance of TriggerCompartmentShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TriggerCompartmentShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TriggerCompartmentShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TriggerCompartmentShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TriggerCompartmentShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TriggerCompartmentShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, TriggerCompartmentShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TriggerCompartmentShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TriggerCompartmentShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TriggerCompartmentShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TriggerCompartmentShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerCompartmentShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TriggerCompartmentShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TriggerCompartmentShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one TriggerCompartmentShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerCompartmentShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TriggerCompartmentShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TriggerCompartmentShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TriggerCompartmentShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TriggerCompartmentShape instance = element as TriggerCompartmentShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TriggerCompartmentShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TriggerCompartmentShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer ExampleConnectorSerializer for DomainClass ExampleConnector.
	/// </summary>
	public partial class ExampleConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// ExampleConnectorSerializer Constructor
		/// </summary>
		public ExampleConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ExampleConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleConnector"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ExampleConnector.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"exampleConnectorMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ExampleConnector in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ExampleConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ExampleConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ExampleConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ExampleConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ExampleConnector, a new ExampleConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ExampleConnector instance, or null if the reader is not pointing to a serialized ExampleConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ExampleConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ExampleConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ExampleConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ExampleConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ExampleConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ExampleConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ExampleConnector instance should be created.</param>	
		/// <returns>Created ExampleConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ExampleConnector(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ExampleConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ExampleConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ExampleConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ExampleConnector itself) instance of ExampleConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ExampleConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ExampleConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ExampleConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ExampleConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ExampleConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ExampleConnector.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ExampleConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ExampleConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ExampleConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ExampleConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ExampleConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ExampleConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ExampleConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ExampleConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ExampleConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ExampleConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ExampleConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ExampleConnector instance = element as ExampleConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ExampleConnector!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ExampleConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer RelacionTablaConnectorSerializer for DomainClass RelacionTablaConnector.
	/// </summary>
	public partial class RelacionTablaConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// RelacionTablaConnectorSerializer Constructor
		/// </summary>
		public RelacionTablaConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of RelacionTablaConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"relacionTablaConnector"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of RelacionTablaConnector.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerRelacionTablaConnector"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of RelacionTablaConnector in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one RelacionTablaConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the RelacionTablaConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory RelacionTablaConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of RelacionTablaConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized RelacionTablaConnector, a new RelacionTablaConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created RelacionTablaConnector instance, or null if the reader is not pointing to a serialized RelacionTablaConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "RelacionTablaConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "RelacionTablaConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						RelacionTablaConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as RelacionTablaConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of RelacionTablaConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of RelacionTablaConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new RelacionTablaConnector instance should be created.</param>	
		/// <returns>Created RelacionTablaConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new RelacionTablaConnector(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from RelacionTablaConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from RelacionTablaConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(RelacionTablaConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including RelacionTablaConnector itself) instance of RelacionTablaConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "RelacionTablaConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "RelacionTablaConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						RelacionTablaConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as RelacionTablaConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of RelacionTablaConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, RelacionTablaConnector.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from RelacionTablaConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from RelacionTablaConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(RelacionTablaConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized RelacionTablaConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">RelacionTablaConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the RelacionTablaConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the RelacionTablaConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one RelacionTablaConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">RelacionTablaConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given RelacionTablaConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">RelacionTablaConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the RelacionTablaConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			RelacionTablaConnector instance = element as RelacionTablaConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of RelacionTablaConnector!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">RelacionTablaConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer TriggerReferencesTableConnectorSerializer for DomainClass TriggerReferencesTableConnector.
	/// </summary>
	public partial class TriggerReferencesTableConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// TriggerReferencesTableConnectorSerializer Constructor
		/// </summary>
		public TriggerReferencesTableConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TriggerReferencesTableConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"triggerReferencesTableConnector"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of TriggerReferencesTableConnector.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"monikerTriggerReferencesTableConnector"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of TriggerReferencesTableConnector in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TriggerReferencesTableConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TriggerReferencesTableConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TriggerReferencesTableConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of TriggerReferencesTableConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TriggerReferencesTableConnector, a new TriggerReferencesTableConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TriggerReferencesTableConnector instance, or null if the reader is not pointing to a serialized TriggerReferencesTableConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TriggerReferencesTableConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TriggerReferencesTableConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						TriggerReferencesTableConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TriggerReferencesTableConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TriggerReferencesTableConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TriggerReferencesTableConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TriggerReferencesTableConnector instance should be created.</param>	
		/// <returns>Created TriggerReferencesTableConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new TriggerReferencesTableConnector(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TriggerReferencesTableConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TriggerReferencesTableConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TriggerReferencesTableConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TriggerReferencesTableConnector itself) instance of TriggerReferencesTableConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TriggerReferencesTableConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TriggerReferencesTableConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TriggerReferencesTableConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TriggerReferencesTableConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TriggerReferencesTableConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, TriggerReferencesTableConnector.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TriggerReferencesTableConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TriggerReferencesTableConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TriggerReferencesTableConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TriggerReferencesTableConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerReferencesTableConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TriggerReferencesTableConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TriggerReferencesTableConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one TriggerReferencesTableConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TriggerReferencesTableConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TriggerReferencesTableConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TriggerReferencesTableConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TriggerReferencesTableConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TriggerReferencesTableConnector instance = element as TriggerReferencesTableConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TriggerReferencesTableConnector!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TriggerReferencesTableConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Serializer DBDiagramSerializer for DomainClass DBDiagram.
	/// </summary>
	public partial class DBDiagramSerializer : DslDiagrams::DiagramSerializer
	{
		#region Constructor
		/// <summary>
		/// DBDiagramSerializer Constructor
		/// </summary>
		public DBDiagramSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of DBDiagram.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"dBDiagram"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of DBDiagram.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"dBDiagramMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of DBDiagram in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one DBDiagram instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the DBDiagram element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory DBDiagram instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					DBSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							DBSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of DBDiagram based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized DBDiagram, a new DBDiagram instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created DBDiagram instance, or null if the reader is not pointing to a serialized DBDiagram instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBDiagram" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "DBDiagram".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						DBDiagramSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBDiagramSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of DBDiagram based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of DBDiagram.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new DBDiagram instance should be created.</param>	
		/// <returns>Created DBDiagram instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					DBSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new DBDiagram(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from DBDiagram, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from DBDiagram.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBDiagram.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including DBDiagram itself) instance of DBDiagram based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "DBDiagram" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "DBDiagram".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						DBDiagramSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DBDiagramSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of DBDiagram based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DBSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				DBSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, DBDiagram.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				DBSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from DBDiagram, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from DBDiagram.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DBDiagram.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized DBDiagram instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBDiagram instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the DBDiagram instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the DBDiagram instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			DBSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one DBDiagram instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">DBDiagram instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				DBSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given DBDiagram instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBDiagram instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the DBDiagram instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			DBDiagram instance = element as DBDiagram;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DBDiagram!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DBDiagram instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior DBSerializationBehavior.
	/// This is the abstract base of the double-derived implementation.
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
	public abstract class DBSerializationBehaviorBase : DslModeling::DomainXmlSerializationBehavior
	{
		///<summary>
		/// The xml namespace used by this domain model when serializing
		///</summary>
		public const string DomainModelXmlNamespace = @"http://schemas.microsoft.com/dsltools/DB";
	
		#region Member Variables
		/// <summary>
		/// A list of DomainClass Ids mapped to DomainClassXmlSerializer types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry> serializerTypes;
	
		/// <summary>
		/// A list of xml namespaces mapped to domain model types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerNamespaceEntry> namespaceEntries;
	
		#endregion
	
		#region Constructor
		/// <summary>
		/// Protected constructor to prevent public instantiation.
		/// </summary>
		protected DBSerializationBehaviorBase() : base() { }
		#endregion
		
		#region Protected Methods
		/// <summary>
		/// Allows custom serializers to be added.
		/// Base implementation doesn't do anything.
		/// </summary>
		/// <returns>Custom serializer types, null or empty list if there's no custom serializer types.</returns>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected virtual global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> CustomSerializerTypes
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return null; }
		}
		#endregion
	
		#region Public Methods
		/// <summary>
		/// This provides a mapping from DomainClass Id to DomainXmlSerializer implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> AllSerializers
		{
			get
			{
				if (DBSerializationBehavior.serializerTypes == null)
				{
					global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> customSerializerTypes = this.CustomSerializerTypes;
					int customSerializerCount = (customSerializerTypes == null ? 0 : customSerializerTypes.Count);
					DBSerializationBehavior.serializerTypes = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry>(34 + customSerializerCount);
	
					#region Serializers defined in this model
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(DBModel.DomainClassId, typeof(DBModelSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ExampleElement.DomainClassId, typeof(ExampleElementSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Tabla.DomainClassId, typeof(TablaSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Vista.DomainClassId, typeof(VistaSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ProcedimientoAlmacenado.DomainClassId, typeof(ProcedimientoAlmacenadoSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Campo.DomainClassId, typeof(CampoSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClavePrimaria.DomainClassId, typeof(ClavePrimariaSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Relacion.DomainClassId, typeof(RelacionSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Trigger.DomainClassId, typeof(TriggerSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Evento.DomainClassId, typeof(EventoSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ExampleModelHasElements.DomainClassId, typeof(ExampleModelHasElementsSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ExampleElementReferencesTargets.DomainClassId, typeof(ExampleElementReferencesTargetsSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(DBModelTieneTabla.DomainClassId, typeof(DBModelTieneTablaSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(DBModelTieneVista.DomainClassId, typeof(DBModelTieneVistaSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(DBModelTieneProcedimientoAlmacenado.DomainClassId, typeof(DBModelTieneProcedimientoAlmacenadoSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TablaTieneCampo.DomainClassId, typeof(TablaTieneCampoSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TablaTieneClavePrimaria.DomainClassId, typeof(TablaTieneClavePrimariaSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(DBModelTieneRelacion.DomainClassId, typeof(DBModelTieneRelacionSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(RelacionReferenciasTabla.DomainClassId, typeof(RelacionReferenciasTablaSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TriggerTieneEvento.DomainClassId, typeof(TriggerTieneEventoSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TriggerReferenciasTabla.DomainClassId, typeof(TriggerReferenciasTablaSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(DBModelTieneTrigger.DomainClassId, typeof(DBModelTieneTriggerSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ExampleShape.DomainClassId, typeof(ExampleShapeSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TablaShape.DomainClassId, typeof(TablaShapeSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ProcedimientoAlmacenadoShape.DomainClassId, typeof(ProcedimientoAlmacenadoShapeSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(VistaShape.DomainClassId, typeof(VistaShapeSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(RelacionShape.DomainClassId, typeof(RelacionShapeSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(EventoShape.DomainClassId, typeof(EventoShapeSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TablaCompartmentShape.DomainClassId, typeof(TablaCompartmentShapeSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TriggerCompartmentShape.DomainClassId, typeof(TriggerCompartmentShapeSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ExampleConnector.DomainClassId, typeof(ExampleConnectorSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(RelacionTablaConnector.DomainClassId, typeof(RelacionTablaConnectorSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TriggerReferencesTableConnector.DomainClassId, typeof(TriggerReferencesTableConnectorSerializer)));
					DBSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(DBDiagram.DomainClassId, typeof(DBDiagramSerializer)));
					#endregion
					
					// Custom ones
					if (customSerializerCount > 0)
					{
						DBSerializationBehavior.serializerTypes.AddRange(customSerializerTypes);
					}
				}
				return DBSerializationBehavior.serializerTypes.AsReadOnly();
			}
		}
		
		/// <summary>
		/// This provides a mapping from xml namespaces to domain model implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		//[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerNamespaceEntry> AllNamespaces
		{
			get
			{
				if (DBSerializationBehavior.namespaceEntries == null)
				{
					DBSerializationBehavior.namespaceEntries = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerNamespaceEntry>();
					DBSerializationBehavior.namespaceEntries.Add(new DslModeling::DomainXmlSerializerNamespaceEntry(DomainModelXmlNamespace, typeof(global::edzzn.DB.DBDomainModel)));
				}
				return DBSerializationBehavior.namespaceEntries.AsReadOnly();
			}
		}
		
		#endregion
	}
	
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior DBSerializationBehavior.
	/// This is the concrete type of the double-derived implementation.
	/// </summary>
	public sealed partial class DBSerializationBehavior : DBSerializationBehaviorBase
	{
		#region Singleton Instance
		/// <summary>
		/// Singleton instance.
		/// </summary>
		private static DBSerializationBehavior instance;
	
		/// <summary>
		/// Singleton instance.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		public static DBSerializationBehavior Instance
		{
			get
			{	// No need for synchronization. Most likely running in single-thread environment, and creating an extra instance
				// doesn't really hurt.
				if (DBSerializationBehavior.instance == null)
					DBSerializationBehavior.instance = new DBSerializationBehavior ();
				return DBSerializationBehavior.instance;
			}
		}
	
		/// <summary>
		/// Private constructor to prevent public instantiation.
		/// </summary>
		private DBSerializationBehavior() : base() { }
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Moniker resolver for serialization behavior DBSerializationBehavior.
	/// </summary>
	public partial class DBSerializationBehaviorMonikerResolver : DBSerializationBehaviorMonikerResolverBase
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public DBSerializationBehaviorMonikerResolver(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base(store,directory)
		{
		}
	}
	
	/// <summary>
	/// Base moniker resolver for serialization behavior DBSerializationBehavior.
	/// </summary>
	public partial class DBSerializationBehaviorMonikerResolverBase : DslModeling::SimpleMonikerResolver
	{
		#region Member Variables
		/// <summary>
		/// Look-up directory to find serializers for domain classes.
		/// </summary>
		private DslModeling::DomainXmlSerializerDirectory directory;
		#endregion
	
		#region Constructor
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public DBSerializationBehaviorMonikerResolverBase(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base (store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException("directory");
			#endregion
	
			this.directory = directory;
		}
		#endregion
	
		#region Base Overrides
		/// <summary>
		/// Tells if a DomainClass can be monikerized or not.
		/// </summary>
		/// <param name="domainClassInfo">DomainClassInfo of the DomainClass to be checked.</param>
		/// <returns>True if the DomainClass can be monikerized, false otherwise.</returns>
		protected override bool CanBeMonikerized(DslModeling::DomainClassInfo domainClassInfo)
		{
			if (this.IsDisposed || this.directory == null || domainClassInfo == null)
				return false;
				
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(domainClassInfo.Id);
			if (serializer != null)
				return (!string.IsNullOrEmpty(serializer.MonikerTagName));
			return false;
		}
			
		/// <summary>
		/// Calculate the fully qualified monikerized string of the given ModelElement.
		/// </summary>
		/// <param name="mel">ModelElement to get moniker from.</param>
		/// <returns>Calculated moniker string, returns null or empty string is the given ModelElement cannot be monikerized.</returns>
		protected override string CalculateQualifiedName(DslModeling::ModelElement mel)
		{
			if (this.IsDisposed || this.directory == null || mel == null)
				return string.Empty;
	
			string result = string.Empty;
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(mel.GetDomainClass().Id);
			if (serializer != null)
				result = serializer.CalculateQualifiedName(this.directory, mel);
			return result;
		}
		
		/// <summary>
		/// Called at the end of synchronization when they're unresolved monikers.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		protected override void OnUnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				DBSerializationBehaviorSerializationMessages.UnresolvedMoniker(serializationResult, moniker);
			}
		}
		
		/// <summary>
		/// Called when resolving a moniker causes a duplicate link to be created.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Moniker that causes duplicate link to be created.</param>
		protected override void OnMonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				DBSerializationBehaviorSerializationMessages.MonikerResolvedToDuplicateLink(serializationResult, moniker);
			}
			base.OnMonikerResolvedToDuplicateLink(serializationResult, moniker);
		}
		
		/// <summary>
		/// Called when two new elements are giving the same moniker, which will cause ambiguity during moniker resolution.
		/// </summary>
		/// <param name="context">SerializationContext to store error/warning messages.</param>
		/// <param name="moniker">Moniker that both elements give.</param>
		/// <param name="element1">The first element giving the moniker.</param>
		/// <param name="element2">The second element giving the same moniker.</param>
		protected override void OnAmbiguousMoniker(DslModeling::SerializationContext context, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			if (context != null)
			{
				DBSerializationBehaviorSerializationMessages.AmbiguousMoniker(context, moniker, element1, element2);
			}
			base.OnAmbiguousMoniker(context, moniker, element1, element2);
		}
		
		/// <summary>
		/// Error message for UnresolvedMonikerException.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected override string UnresolvedMonikerExceptionMessage
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return DBSerializationBehaviorSerializationMessages.ResourceManager.GetString("CannotOpenDocument"); }
		}
		#endregion
	}
}

namespace edzzn.DB
{
	/// <summary>
	/// Utility class to provide serialization messages
	/// </summary>
	public static partial class DBSerializationBehaviorSerializationMessages
	{
		/// <summary>
		/// ResourceManager to get serialization messages from.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)] // Will trigger creation otherwise.
		public static global::System.Resources.ResourceManager ResourceManager
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return DBDomainModel.SingletonResourceManager; }
		}
	
		#region Warnings
		/// <summary>
		/// Add a warning for ambiguous schemas.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace to be resolved.</param>
		/// <param name="schemaPath">The schema that is used to resolve the definition of the target namespace.</param>
		public static void AmbiguousSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace, string schemaPath)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(schemaPath));
			if (string.IsNullOrEmpty(schemaPath))
				throw new global::System.ArgumentNullException("schemaPath");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousSchema"),
					targetNamespace,
					schemaPath
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a full-form relationship seems to be serialized in short-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingFullFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingFullFormRelationship"),
					reader.Name,
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a short-form relationship seems to be serialized in full-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingShortFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingShortFormRelationship"),
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for invalid property value with the given type, which will be ignored.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this warning.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void IgnoredPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("IgnoredPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for missing "Id" property.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="newId">Auto-generated new Id.</param>
		public static void MissingId(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Guid newId)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingId"),
					newId.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
			
		/// <summary>
		/// Add an warning for moniker resolved to duplicate link. The moniker will be ignored.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Offending moniker.</param>
		public static void MonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MonikerResolvedToDuplicateLink"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
		
		/// <summary>
		/// Add a warning for no schema found for the given target namespace, schema validation will be skipped in this case.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace that cannot be resolved.</param>
		public static void NoSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("NoSchema"),
					targetNamespace
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for schema validation error.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="message">Validation message reported from schema validation.</param>
		public static void SchemaValidationError(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string message)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(message));
			if (string.IsNullOrEmpty(message))
				throw new global::System.ArgumentNullException("message");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				message,
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an warning for unexpected XML element.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		public static void UnexpectedXmlElement(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
				
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnexpectedXmlElement"),
					reader.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	
		#region Errors
		/// <summary>
		/// Add an error for ambiguous moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="moniker">The ambiguous moniker string.</param>
		/// <param name="element1">The first element using the given moniker.</param>
		/// <param name="element2">The second element using the given moniker.</param>
		public static void AmbiguousMoniker(DslModeling::SerializationContext serializationContext, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			global::System.Diagnostics.Debug.Assert(element1 != null);
			if (element1 == null)
				throw new global::System.ArgumentNullException("element1");
			global::System.Diagnostics.Debug.Assert(element2 != null);
			if (element2 == null)
				throw new global::System.ArgumentNullException("element2");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousMoniker"),
					moniker,
					DslModeling::SerializationUtilities.GetElementName(element1),
					DslModeling::SerializationUtilities.GetElementName(element2)
				),
				null	// No location info available
			);
		}
		
		/// <summary>
		/// Add an error for not able to monikerize an instance of the given DomainClass.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="domainClassName">Name of the DomainClass whose instance cannot be monikerized.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Generated code.")]	
		public static void CannotMonikerizeElement(DslModeling::SerializationContext serializationContext, string domainClassName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(domainClassName));
			if (string.IsNullOrEmpty(domainClassName))
				throw new global::System.ArgumentNullException("domainClassName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext.Result,
				null,	/* no location available for this error, because save failed. */
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("CannotMonikerizeElement"),
					domainClassName
				),
				0,
				0
			);
		}
		
		/// <summary>
		/// Add an error for dangling relationship instance.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type name of the relationship.</param>
		public static void DanglingRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(relationshipType));
			if (string.IsNullOrEmpty(relationshipType))
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("DanglingRelationship"),
					relationshipType
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for invalid property value with given type.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this error.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void InvalidPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("InvalidPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for missing moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="monikerAttributeName">Name of the attribute that should hold the moniker.</param>
		public static void MissingMoniker(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string monikerAttributeName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerAttributeName));
			if (string.IsNullOrEmpty(monikerAttributeName))
				throw new global::System.ArgumentNullException("monikerAttributeName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingMoniker"),
					monikerAttributeName
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for unresolved moniker.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		public static void UnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnresolvedMoniker"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
	
		/// <summary>
		/// Add an error for Version mismatch.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="expectedVersion">The version that's expected.</param>
		/// <param name="actualVersion">Actual version from the file.</param>
		public static void VersionMismatch(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Version expectedVersion, global::System.Version actualVersion)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(expectedVersion != null);
			if (expectedVersion == null)
				throw new global::System.ArgumentNullException("expectedVersion");
			global::System.Diagnostics.Debug.Assert(actualVersion != null);
			if (actualVersion == null)
				throw new global::System.ArgumentNullException("actualVersion");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("VersionMismatch"), 
					actualVersion.ToString(4), 
					expectedVersion.ToString(4)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	}
}
namespace edzzn.DB
{
	/// <summary>
	/// Provides an implementation of the IDomainModelSerializer interface
	/// that can be used to serialize / deserialize the DB domain model.
	/// </summary>
	/// <remarks>Double-derived class - the default implementation is in DBDomainModelSerializerBase.
	/// This class exist so users can customize behavior easily.</remarks>
	[global::System.ComponentModel.Composition.Export(typeof(DslModeling::IDomainModelSerializer))]
	[DslModeling::DomainModelSerializer(typeof(global::edzzn.DB.DBDomainModel), global::edzzn.DB.DBSerializationBehavior.DomainModelXmlNamespace, "DB")]
	public partial class DBDomainModelSerializer : DBDomainModelSerializerBase
	{
	}
	
	
	/// <summary>
	/// Base class that implements IDomainModelSerializer
	/// </summary>
	public abstract partial class DBDomainModelSerializerBase : DslModeling::IDomainModelSerializer
	{
	
		#region Public properties
	
		/// <summary>
		/// The XML namespace used when serializing the domain model
		/// </summary>
		public virtual string DomainModelNamespace
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return global::edzzn.DB.DBSerializationBehavior.DomainModelXmlNamespace; }
		}
	
		/// <summary>
		/// Returns true: this DSL can be serialized / deserialized directly.
		/// </summary>
		public virtual bool IsSerializable
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return true; }
		}
	
		/// <summary>
		/// The type of the domain model
		/// </summary>
		public virtual global::System.Type DomainModelType
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return typeof(global::edzzn.DB.DBDomainModel); }
		}
	
		/// <summary>
		/// File extension used for model files of this kind of domain model
		/// </summary>
		/// <remarks>If a domain model type cannot be serialized independently, or cannot
		/// be serialized to a file, it should return null or empty.</remarks>
		public string ModelFileExtension
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return "DB"; }
		}
	
		#endregion
		
		
		#region Load / Save model methods
		
		/// <summary>
		/// Loads a DBModel instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="partition">Partition in which the new DBModel instance will be created.</param>
		/// <param name="fileName">Name of the file from which the DBModel instance will be deserialized.</param>
		/// <param name="serializerLocator">Used to locate any additional domain model types required to load the model. Can be null.</param>
		/// <returns>The loaded DBModel instance.</returns>
		public virtual DslModeling::ModelElement LoadModel(DslModeling::SerializationResult serializationResult, 
			DslModeling::Partition partition, 
			string fileName, 
			DslModeling::ISerializerLocator serializerLocator)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (partition == null) { throw new global::System.ArgumentNullException("partition"); }
			if (string.IsNullOrEmpty(fileName)) { throw new global::System.ArgumentNullException("fileName"); }
	
			return DBSerializationHelper.Instance.LoadModel(serializationResult, partition, fileName, null, null, serializerLocator);
		}
	
		/// <summary>
		/// Saves the given model root to the given file, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">DBModel instance to be saved.</param>
		/// <param name="fileName">Name of the file in which the DBModel instance will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the DBModel instance.</param>
		public void SaveModel(DslModeling::SerializationResult serializationResult, 
			DslModeling::ModelElement modelRoot, 
			string fileName, 
			System.Text.Encoding encoding)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelRoot == null) { throw new global::System.ArgumentNullException("modelRoot"); }
			if (string.IsNullOrEmpty("fileName")) { throw new global::System.ArgumentNullException("fileName"); }
	
			global::edzzn.DB.DBModel rootElement = modelRoot as global::edzzn.DB.DBModel;
			if (rootElement == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::edzzn.DB.DBDomainModel.SingletonResourceManager.GetString("InvalidSaveRootElementType"),
					modelRoot.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "modelRoot");
	
			}
	
			DBSerializationHelper.Instance.SaveModel(serializationResult, rootElement, fileName,encoding, true);
		}
	
		#endregion
	
		#region Load / Save model and diagram methods
	
		/// <summary>
		/// Calculates and returns the name of the diagram file for the specified model file
		/// </summary>
		/// <param name="modelFileName">The relevant model file name</param>
		/// <returns>Name of the associated diagram file</returns>
		/// <remarks>There is no guarantee that either the model file or the calculated diagram file exist.</remarks>
		public virtual string CalculateDiagramFileName(string modelFileName)
		{
			if (string.IsNullOrEmpty(modelFileName))
			{
				throw new global::System.ArgumentNullException("modelFileName");
			}
			return modelFileName + ".diagram";
		}
	
		/// <summary>
		/// Loads a DBModel instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="modelPartition">Partition in which the new DBModel instance will be created.</param>
		/// <param name="modelFileName">Name of the file from which the DBModel instance will be deserialized.</param>
		/// <param name="diagramPartition">Partition in which the new DBDiagram instance will be created.</param>
		/// <param name="diagramFileName">Name of the file from which the DBDiagram instance will be deserialized.</param>
		/// <param name="serializerLocator">Used to locate any additional domain model types required to load the model. Can be null.</param>
		/// <returns>The loaded DBModel instance.</returns>
		public DslModeling::ModelElement LoadModelAndDiagram(DslModeling::SerializationResult serializationResult, 
			DslModeling::Partition modelPartition, 
			string modelFileName, 
			DslModeling::Partition diagramPartition, 
			string diagramFileName, 
			DslModeling::ISerializerLocator serializerLocator)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelPartition == null) { throw new global::System.ArgumentNullException("modelPartition"); }
			if (string.IsNullOrEmpty(modelFileName)) { throw new global::System.ArgumentNullException("modelFileName"); }
			if (diagramPartition == null) { throw new global::System.ArgumentNullException("diagramPartition"); }
			if (string.IsNullOrEmpty(diagramFileName)) { throw new global::System.ArgumentNullException("diagramFileName"); }
	
			return DBSerializationHelper.Instance.LoadModelAndDiagram(serializationResult, modelPartition, modelFileName, diagramPartition, diagramFileName, null, null, serializerLocator);
		}
	
		/// <summary>
		/// Saves the given DBModel and DBDiagram to the given files, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">DBModel instance to be saved.</param>
		/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
		/// <param name="diagram">DBDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the diagram.</param>
		public void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, 
			DslModeling::ModelElement modelRoot, 
			string modelFileName, 
			DslModeling::ModelElement diagram, 
			string diagramFileName, 
			System.Text.Encoding encoding)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelRoot == null) { throw new global::System.ArgumentNullException("modelRoot"); }
			if (string.IsNullOrEmpty("modelFileName")) { throw new global::System.ArgumentNullException("modelFileName"); }
			if (diagram == null) { throw new global::System.ArgumentNullException("diagram"); }
			if (string.IsNullOrEmpty("diagramFileName")) { throw new global::System.ArgumentNullException("diagramFileName"); }
	
			global::edzzn.DB.DBModel typedRoot = modelRoot as global::edzzn.DB.DBModel;
			if (typedRoot == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::edzzn.DB.DBDomainModel.SingletonResourceManager.GetString("InvalidSaveRootElementType"),
					modelRoot.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "modelRoot");
			}
			global::edzzn.DB.DBDiagram typedDiagram = diagram as global::edzzn.DB.DBDiagram;
			if (typedDiagram == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::edzzn.DB.DBDomainModel.SingletonResourceManager.GetString("InvalidSaveDiagramType"),
					diagram.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "diagram");
			}
	
			DBSerializationHelper.Instance.SaveModelAndDiagram(serializationResult, typedRoot, modelFileName, typedDiagram, diagramFileName, encoding, true);
		}
	
		#endregion
		
	}
}


